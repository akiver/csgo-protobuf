// @generated by protobuf-ts 2.0.7 with parameter generate_dependencies
// @generated from protobuf file "steammessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgProtoBufHeader
 */
export interface CMsgProtoBufHeader {
    /**
     * @generated from protobuf field: optional fixed64 client_steam_id = 1;
     */
    clientSteamId?: bigint;
    /**
     * @generated from protobuf field: optional int32 client_session_id = 2;
     */
    clientSessionId?: number;
    /**
     * @generated from protobuf field: optional uint32 source_app_id = 3;
     */
    sourceAppId?: number;
    /**
     * @generated from protobuf field: optional fixed64 job_id_source = 10;
     */
    jobIdSource?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 job_id_target = 11;
     */
    jobIdTarget?: bigint;
    /**
     * @generated from protobuf field: optional string target_job_name = 12;
     */
    targetJobName?: string;
    /**
     * @generated from protobuf field: optional int32 eresult = 13;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string error_message = 14;
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: optional uint32 ip = 15;
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional GCProtoBufMsgSrc gc_msg_src = 200;
     */
    gcMsgSrc?: GCProtoBufMsgSrc;
    /**
     * @generated from protobuf field: optional uint32 gc_dir_index_source = 201;
     */
    gcDirIndexSource?: number;
}
/**
 * @generated from protobuf message CMsgWebAPIKey
 */
export interface CMsgWebAPIKey {
    /**
     * @generated from protobuf field: optional uint32 status = 1;
     */
    status?: number;
    /**
     * @generated from protobuf field: optional uint32 account_id = 2;
     */
    accountId?: number;
    /**
     * @generated from protobuf field: optional uint32 publisher_group_id = 3;
     */
    publisherGroupId?: number;
    /**
     * @generated from protobuf field: optional uint32 key_id = 4;
     */
    keyId?: number;
    /**
     * @generated from protobuf field: optional string domain = 5;
     */
    domain?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest
 */
export interface CMsgHttpRequest {
    /**
     * @generated from protobuf field: optional uint32 request_method = 1;
     */
    requestMethod?: number;
    /**
     * @generated from protobuf field: optional string hostname = 2;
     */
    hostname?: string;
    /**
     * @generated from protobuf field: optional string url = 3;
     */
    url?: string;
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.RequestHeader headers = 4;
     */
    headers: CMsgHttpRequest_RequestHeader[];
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam get_params = 5;
     */
    getParams: CMsgHttpRequest_QueryParam[];
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam post_params = 6;
     */
    postParams: CMsgHttpRequest_QueryParam[];
    /**
     * @generated from protobuf field: optional bytes body = 7;
     */
    body?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 absolute_timeout = 8;
     */
    absoluteTimeout?: number;
}
/**
 * @generated from protobuf message CMsgHttpRequest.RequestHeader
 */
export interface CMsgHttpRequest_RequestHeader {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest.QueryParam
 */
export interface CMsgHttpRequest_QueryParam {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgWebAPIRequest
 */
export interface CMsgWebAPIRequest {
    /**
     * @generated from protobuf field: optional string UNUSED_job_name = 1 [json_name = "UNUSEDJobName"];
     */
    uNUSEDJobName?: string;
    /**
     * @generated from protobuf field: optional string interface_name = 2;
     */
    interfaceName?: string;
    /**
     * @generated from protobuf field: optional string method_name = 3;
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional uint32 version = 4;
     */
    version?: number;
    /**
     * @generated from protobuf field: optional CMsgWebAPIKey api_key = 5;
     */
    apiKey?: CMsgWebAPIKey;
    /**
     * @generated from protobuf field: optional CMsgHttpRequest request = 6;
     */
    request?: CMsgHttpRequest;
    /**
     * @generated from protobuf field: optional uint32 routing_app_id = 7;
     */
    routingAppId?: number;
}
/**
 * @generated from protobuf message CMsgHttpResponse
 */
export interface CMsgHttpResponse {
    /**
     * @generated from protobuf field: optional uint32 status_code = 1;
     */
    statusCode?: number;
    /**
     * @generated from protobuf field: repeated CMsgHttpResponse.ResponseHeader headers = 2;
     */
    headers: CMsgHttpResponse_ResponseHeader[];
    /**
     * @generated from protobuf field: optional bytes body = 3;
     */
    body?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgHttpResponse.ResponseHeader
 */
export interface CMsgHttpResponse_ResponseHeader {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccounts
 */
export interface CMsgAMFindAccounts {
    /**
     * @generated from protobuf field: optional uint32 search_type = 1;
     */
    searchType?: number;
    /**
     * @generated from protobuf field: optional string search_string = 2;
     */
    searchString?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccountsResponse
 */
export interface CMsgAMFindAccountsResponse {
    /**
     * @generated from protobuf field: repeated fixed64 steam_id = 1;
     */
    steamId: bigint[];
}
/**
 * @generated from protobuf message CMsgNotifyWatchdog
 */
export interface CMsgNotifyWatchdog {
    /**
     * @generated from protobuf field: optional uint32 source = 1;
     */
    source?: number;
    /**
     * @generated from protobuf field: optional uint32 alert_type = 2;
     */
    alertType?: number;
    /**
     * @generated from protobuf field: optional uint32 alert_destination = 3;
     */
    alertDestination?: number;
    /**
     * @generated from protobuf field: optional bool critical = 4;
     */
    critical?: boolean;
    /**
     * @generated from protobuf field: optional uint32 time = 5;
     */
    time?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 6;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string text = 7;
     */
    text?: string;
}
/**
 * @generated from protobuf message CMsgAMGetLicenses
 */
export interface CMsgAMGetLicenses {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgPackageLicense
 */
export interface CMsgPackageLicense {
    /**
     * @generated from protobuf field: optional uint32 package_id = 1;
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional uint32 time_created = 2;
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_id = 3;
     */
    ownerId?: number;
}
/**
 * @generated from protobuf message CMsgAMGetLicensesResponse
 */
export interface CMsgAMGetLicensesResponse {
    /**
     * @generated from protobuf field: repeated CMsgPackageLicense license = 1;
     */
    license: CMsgPackageLicense[];
    /**
     * @generated from protobuf field: optional uint32 result = 2;
     */
    result?: number;
}
/**
 * @generated from protobuf message CMsgAMGetUserGameStats
 */
export interface CMsgAMGetUserGameStats {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 2;
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: repeated uint32 stats = 3;
     */
    stats: number[];
}
/**
 * @generated from protobuf message CMsgAMGetUserGameStatsResponse
 */
export interface CMsgAMGetUserGameStatsResponse {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 game_id = 2;
     */
    gameId?: bigint;
    /**
     * @generated from protobuf field: optional int32 eresult = 3;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: repeated CMsgAMGetUserGameStatsResponse.Stats stats = 4;
     */
    stats: CMsgAMGetUserGameStatsResponse_Stats[];
    /**
     * @generated from protobuf field: repeated CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks = 5;
     */
    achievementBlocks: CMsgAMGetUserGameStatsResponse_Achievement_Blocks[];
}
/**
 * @generated from protobuf message CMsgAMGetUserGameStatsResponse.Stats
 */
export interface CMsgAMGetUserGameStatsResponse_Stats {
    /**
     * @generated from protobuf field: optional uint32 stat_id = 1;
     */
    statId?: number;
    /**
     * @generated from protobuf field: optional uint32 stat_value = 2;
     */
    statValue?: number;
}
/**
 * @generated from protobuf message CMsgAMGetUserGameStatsResponse.Achievement_Blocks
 */
export interface CMsgAMGetUserGameStatsResponse_Achievement_Blocks {
    /**
     * @generated from protobuf field: optional uint32 achievement_id = 1;
     */
    achievementId?: number;
    /**
     * @generated from protobuf field: optional uint32 achievement_bit_id = 2;
     */
    achievementBitId?: number;
    /**
     * @generated from protobuf field: optional fixed32 unlock_time = 3;
     */
    unlockTime?: number;
}
/**
 * @generated from protobuf message CMsgGCGetCommandList
 */
export interface CMsgGCGetCommandList {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string command_prefix = 2;
     */
    commandPrefix?: string;
}
/**
 * @generated from protobuf message CMsgGCGetCommandListResponse
 */
export interface CMsgGCGetCommandListResponse {
    /**
     * @generated from protobuf field: repeated string command_name = 1;
     */
    commandName: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGet
 */
export interface CGCMsgMemCachedGet {
    /**
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse
 */
export interface CGCMsgMemCachedGetResponse {
    /**
     * @generated from protobuf field: repeated CGCMsgMemCachedGetResponse.ValueTag values = 1;
     */
    values: CGCMsgMemCachedGetResponse_ValueTag[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export interface CGCMsgMemCachedGetResponse_ValueTag {
    /**
     * @generated from protobuf field: optional bool found = 1;
     */
    found?: boolean;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet
 */
export interface CGCMsgMemCachedSet {
    /**
     * @generated from protobuf field: repeated CGCMsgMemCachedSet.KeyPair keys = 1;
     */
    keys: CGCMsgMemCachedSet_KeyPair[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet.KeyPair
 */
export interface CGCMsgMemCachedSet_KeyPair {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedDelete
 */
export interface CGCMsgMemCachedDelete {
    /**
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedStats
 */
export interface CGCMsgMemCachedStats {
}
/**
 * @generated from protobuf message CGCMsgMemCachedStatsResponse
 */
export interface CGCMsgMemCachedStatsResponse {
    /**
     * @generated from protobuf field: optional uint64 curr_connections = 1;
     */
    currConnections?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_get = 2;
     */
    cmdGet?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_set = 3;
     */
    cmdSet?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_flush = 4;
     */
    cmdFlush?: bigint;
    /**
     * @generated from protobuf field: optional uint64 get_hits = 5;
     */
    getHits?: bigint;
    /**
     * @generated from protobuf field: optional uint64 get_misses = 6;
     */
    getMisses?: bigint;
    /**
     * @generated from protobuf field: optional uint64 delete_hits = 7;
     */
    deleteHits?: bigint;
    /**
     * @generated from protobuf field: optional uint64 delete_misses = 8;
     */
    deleteMisses?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_read = 9;
     */
    bytesRead?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_written = 10;
     */
    bytesWritten?: bigint;
    /**
     * @generated from protobuf field: optional uint64 limit_maxbytes = 11;
     */
    limitMaxbytes?: bigint;
    /**
     * @generated from protobuf field: optional uint64 curr_items = 12;
     */
    currItems?: bigint;
    /**
     * @generated from protobuf field: optional uint64 evictions = 13;
     */
    evictions?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes = 14;
     */
    bytes?: bigint;
}
/**
 * @generated from protobuf message CGCMsgSQLStats
 */
export interface CGCMsgSQLStats {
    /**
     * @generated from protobuf field: optional uint32 schema_catalog = 1;
     */
    schemaCatalog?: number;
}
/**
 * @generated from protobuf message CGCMsgSQLStatsResponse
 */
export interface CGCMsgSQLStatsResponse {
    /**
     * @generated from protobuf field: optional uint32 threads = 1;
     */
    threads?: number;
    /**
     * @generated from protobuf field: optional uint32 threads_connected = 2;
     */
    threadsConnected?: number;
    /**
     * @generated from protobuf field: optional uint32 threads_active = 3;
     */
    threadsActive?: number;
    /**
     * @generated from protobuf field: optional uint32 operations_submitted = 4;
     */
    operationsSubmitted?: number;
    /**
     * @generated from protobuf field: optional uint32 prepared_statements_executed = 5;
     */
    preparedStatementsExecuted?: number;
    /**
     * @generated from protobuf field: optional uint32 non_prepared_statements_executed = 6;
     */
    nonPreparedStatementsExecuted?: number;
    /**
     * @generated from protobuf field: optional uint32 deadlock_retries = 7;
     */
    deadlockRetries?: number;
    /**
     * @generated from protobuf field: optional uint32 operations_timed_out_in_queue = 8;
     */
    operationsTimedOutInQueue?: number;
    /**
     * @generated from protobuf field: optional uint32 errors = 9;
     */
    errors?: number;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicense
 */
export interface CMsgAMAddFreeLicense {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 ip_public = 2;
     */
    ipPublic?: number;
    /**
     * @generated from protobuf field: optional uint32 packageid = 3;
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional string store_country_code = 4;
     */
    storeCountryCode?: string;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicenseResponse
 */
export interface CMsgAMAddFreeLicenseResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 purchase_result_detail = 2;
     */
    purchaseResultDetail?: number;
    /**
     * @generated from protobuf field: optional fixed64 transid = 3;
     */
    transid?: bigint;
}
/**
 * @generated from protobuf message CGCMsgGetIPLocation
 */
export interface CGCMsgGetIPLocation {
    /**
     * @generated from protobuf field: repeated fixed32 ips = 1;
     */
    ips: number[];
}
/**
 * @generated from protobuf message CIPLocationInfo
 */
export interface CIPLocationInfo {
    /**
     * @generated from protobuf field: optional uint32 ip = 1;
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional float latitude = 2;
     */
    latitude?: number;
    /**
     * @generated from protobuf field: optional float longitude = 3;
     */
    longitude?: number;
    /**
     * @generated from protobuf field: optional string country = 4;
     */
    country?: string;
    /**
     * @generated from protobuf field: optional string state = 5;
     */
    state?: string;
    /**
     * @generated from protobuf field: optional string city = 6;
     */
    city?: string;
}
/**
 * @generated from protobuf message CGCMsgGetIPLocationResponse
 */
export interface CGCMsgGetIPLocationResponse {
    /**
     * @generated from protobuf field: repeated CIPLocationInfo infos = 1;
     */
    infos: CIPLocationInfo[];
}
/**
 * @generated from protobuf message CGCMsgSystemStatsSchema
 */
export interface CGCMsgSystemStatsSchema {
    /**
     * @generated from protobuf field: optional uint32 gc_app_id = 1;
     */
    gcAppId?: number;
    /**
     * @generated from protobuf field: optional bytes schema_kv = 2;
     */
    schemaKv?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgGetSystemStats
 */
export interface CGCMsgGetSystemStats {
}
/**
 * @generated from protobuf message CGCMsgGetSystemStatsResponse
 */
export interface CGCMsgGetSystemStatsResponse {
    /**
     * @generated from protobuf field: optional uint32 gc_app_id = 1;
     */
    gcAppId?: number;
    /**
     * @generated from protobuf field: optional bytes stats_kv = 2;
     */
    statsKv?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 active_jobs = 3;
     */
    activeJobs?: number;
    /**
     * @generated from protobuf field: optional uint32 yielding_jobs = 4;
     */
    yieldingJobs?: number;
    /**
     * @generated from protobuf field: optional uint32 user_sessions = 5;
     */
    userSessions?: number;
    /**
     * @generated from protobuf field: optional uint32 game_server_sessions = 6;
     */
    gameServerSessions?: number;
    /**
     * @generated from protobuf field: optional uint32 socaches = 7;
     */
    socaches?: number;
    /**
     * @generated from protobuf field: optional uint32 socaches_to_unload = 8;
     */
    socachesToUnload?: number;
    /**
     * @generated from protobuf field: optional uint32 socaches_loading = 9;
     */
    socachesLoading?: number;
    /**
     * @generated from protobuf field: optional uint32 writeback_queue = 10;
     */
    writebackQueue?: number;
    /**
     * @generated from protobuf field: optional uint32 steamid_locks = 11;
     */
    steamidLocks?: number;
    /**
     * @generated from protobuf field: optional uint32 logon_queue = 12;
     */
    logonQueue?: number;
    /**
     * @generated from protobuf field: optional uint32 logon_jobs = 13;
     */
    logonJobs?: number;
}
/**
 * @generated from protobuf message CMsgAMSendEmail
 */
export interface CMsgAMSendEmail {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 email_msg_type = 2;
     */
    emailMsgType?: number;
    /**
     * @generated from protobuf field: optional uint32 email_format = 3;
     */
    emailFormat?: number;
    /**
     * @generated from protobuf field: repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
     */
    personaNameTokens: CMsgAMSendEmail_PersonaNameReplacementToken[];
    /**
     * @generated from protobuf field: optional uint32 source_gc = 6;
     */
    sourceGc?: number;
    /**
     * @generated from protobuf field: repeated CMsgAMSendEmail.ReplacementToken tokens = 7;
     */
    tokens: CMsgAMSendEmail_ReplacementToken[];
}
/**
 * @generated from protobuf message CMsgAMSendEmail.ReplacementToken
 */
export interface CMsgAMSendEmail_ReplacementToken {
    /**
     * @generated from protobuf field: optional string token_name = 1;
     */
    tokenName?: string;
    /**
     * @generated from protobuf field: optional string token_value = 2;
     */
    tokenValue?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export interface CMsgAMSendEmail_PersonaNameReplacementToken {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string token_name = 2;
     */
    tokenName?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmailResponse
 */
export interface CMsgAMSendEmailResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplate
 */
export interface CMsgGCGetEmailTemplate {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 email_msg_type = 2;
     */
    emailMsgType?: number;
    /**
     * @generated from protobuf field: optional int32 email_lang = 3;
     */
    emailLang?: number;
    /**
     * @generated from protobuf field: optional int32 email_format = 4;
     */
    emailFormat?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplateResponse
 */
export interface CMsgGCGetEmailTemplateResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool template_exists = 2;
     */
    templateExists?: boolean;
    /**
     * @generated from protobuf field: optional string template = 3;
     */
    template?: string;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2
 */
export interface CMsgAMGrantGuestPasses2 {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 package_id = 2;
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional int32 passes_to_grant = 3;
     */
    passesToGrant?: number;
    /**
     * @generated from protobuf field: optional int32 days_to_expiration = 4;
     */
    daysToExpiration?: number;
    /**
     * @generated from protobuf field: optional int32 action = 5;
     */
    action?: number;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2Response
 */
export interface CMsgAMGrantGuestPasses2Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 passes_granted = 2;
     */
    passesGranted?: number;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetAccountDetails
 */
export interface CGCSystemMsg_GetAccountDetails {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 appid = 2;
     */
    appid?: number;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetAccountDetails_Response
 */
export interface CGCSystemMsg_GetAccountDetails_Response {
    /**
     * @generated from protobuf field: optional uint32 eresult_deprecated = 1;
     */
    eresultDeprecated?: number;
    /**
     * @generated from protobuf field: optional string account_name = 2;
     */
    accountName?: string;
    /**
     * @generated from protobuf field: optional string persona_name = 3;
     */
    personaName?: string;
    /**
     * @generated from protobuf field: optional bool is_profile_public = 4;
     */
    isProfilePublic?: boolean;
    /**
     * @generated from protobuf field: optional bool is_inventory_public = 5;
     */
    isInventoryPublic?: boolean;
    /**
     * @generated from protobuf field: optional bool is_vac_banned = 7;
     */
    isVacBanned?: boolean;
    /**
     * @generated from protobuf field: optional bool is_cyber_cafe = 8;
     */
    isCyberCafe?: boolean;
    /**
     * @generated from protobuf field: optional bool is_school_account = 9;
     */
    isSchoolAccount?: boolean;
    /**
     * @generated from protobuf field: optional bool is_limited = 10;
     */
    isLimited?: boolean;
    /**
     * @generated from protobuf field: optional bool is_subscribed = 11;
     */
    isSubscribed?: boolean;
    /**
     * @generated from protobuf field: optional uint32 package = 12;
     */
    package?: number;
    /**
     * @generated from protobuf field: optional bool is_free_trial_account = 13;
     */
    isFreeTrialAccount?: boolean;
    /**
     * @generated from protobuf field: optional uint32 free_trial_expiration = 14;
     */
    freeTrialExpiration?: number;
    /**
     * @generated from protobuf field: optional bool is_low_violence = 15;
     */
    isLowViolence?: boolean;
    /**
     * @generated from protobuf field: optional bool is_account_locked_down = 16;
     */
    isAccountLockedDown?: boolean;
    /**
     * @generated from protobuf field: optional bool is_community_banned = 17;
     */
    isCommunityBanned?: boolean;
    /**
     * @generated from protobuf field: optional bool is_trade_banned = 18;
     */
    isTradeBanned?: boolean;
    /**
     * @generated from protobuf field: optional uint32 trade_ban_expiration = 19;
     */
    tradeBanExpiration?: number;
    /**
     * @generated from protobuf field: optional uint32 accountid = 20;
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional uint32 suspension_end_time = 21;
     */
    suspensionEndTime?: number;
    /**
     * @generated from protobuf field: optional string currency = 22;
     */
    currency?: string;
    /**
     * @generated from protobuf field: optional uint32 steam_level = 23;
     */
    steamLevel?: number;
    /**
     * @generated from protobuf field: optional uint32 friend_count = 24;
     */
    friendCount?: number;
    /**
     * @generated from protobuf field: optional uint32 account_creation_time = 25;
     */
    accountCreationTime?: number;
    /**
     * @generated from protobuf field: optional bool is_steamguard_enabled = 27;
     */
    isSteamguardEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bool is_phone_verified = 28;
     */
    isPhoneVerified?: boolean;
    /**
     * @generated from protobuf field: optional bool is_two_factor_auth_enabled = 29;
     */
    isTwoFactorAuthEnabled?: boolean;
    /**
     * @generated from protobuf field: optional uint32 two_factor_enabled_time = 30;
     */
    twoFactorEnabledTime?: number;
    /**
     * @generated from protobuf field: optional uint32 phone_verification_time = 31;
     */
    phoneVerificationTime?: number;
    /**
     * @generated from protobuf field: optional uint64 phone_id = 33;
     */
    phoneId?: bigint;
    /**
     * @generated from protobuf field: optional bool is_phone_identifying = 34;
     */
    isPhoneIdentifying?: boolean;
    /**
     * @generated from protobuf field: optional uint32 rt_identity_linked = 35;
     */
    rtIdentityLinked?: number;
    /**
     * @generated from protobuf field: optional uint32 rt_birth_date = 36;
     */
    rtBirthDate?: number;
    /**
     * @generated from protobuf field: optional string txn_country_code = 37;
     */
    txnCountryCode?: string;
    /**
     * @generated from protobuf field: optional bool has_accepted_china_ssa = 38;
     */
    hasAcceptedChinaSsa?: boolean;
    /**
     * @generated from protobuf field: optional bool is_banned_steam_china = 39;
     */
    isBannedSteamChina?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames
 */
export interface CMsgGCGetPersonaNames {
    /**
     * @generated from protobuf field: repeated fixed64 steamids = 1;
     */
    steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response
 */
export interface CMsgGCGetPersonaNames_Response {
    /**
     * @generated from protobuf field: repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
     */
    succeededLookups: CMsgGCGetPersonaNames_Response_PersonaName[];
    /**
     * @generated from protobuf field: repeated fixed64 failed_lookup_steamids = 2;
     */
    failedLookupSteamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export interface CMsgGCGetPersonaNames_Response_PersonaName {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 2;
     */
    personaName?: string;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship
 */
export interface CMsgGCCheckFriendship {
    /**
     * @generated from protobuf field: optional fixed64 steamid_left = 1;
     */
    steamidLeft?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steamid_right = 2;
     */
    steamidRight?: bigint;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship_Response
 */
export interface CMsgGCCheckFriendship_Response {
    /**
     * @generated from protobuf field: optional bool success = 1;
     */
    success?: boolean;
    /**
     * @generated from protobuf field: optional bool found_friendship = 2;
     */
    foundFriendship?: boolean;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory
 */
export interface CMsgGCMsgMasterSetDirectory {
    /**
     * @generated from protobuf field: optional uint32 master_dir_index = 1;
     */
    masterDirIndex?: number;
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
     */
    dir: CMsgGCMsgMasterSetDirectory_SubGC[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export interface CMsgGCMsgMasterSetDirectory_SubGC {
    /**
     * @generated from protobuf field: optional uint32 dir_index = 1;
     */
    dirIndex?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string box = 3;
     */
    box?: string;
    /**
     * @generated from protobuf field: optional string command_line = 4;
     */
    commandLine?: string;
    /**
     * @generated from protobuf field: optional string gc_binary = 5;
     */
    gcBinary?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export interface CMsgGCMsgMasterSetDirectory_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string message = 2;
     */
    message?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export interface CMsgGCMsgWebAPIJobRequestForwardResponse {
    /**
     * @generated from protobuf field: optional uint32 dir_index = 1;
     */
    dirIndex?: number;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export interface CGCSystemMsg_GetPurchaseTrust_Request {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export interface CGCSystemMsg_GetPurchaseTrust_Response {
    /**
     * @generated from protobuf field: optional bool has_prior_purchase_history = 1;
     */
    hasPriorPurchaseHistory?: boolean;
    /**
     * @generated from protobuf field: optional bool has_no_recent_password_resets = 2;
     */
    hasNoRecentPasswordResets?: boolean;
    /**
     * @generated from protobuf field: optional bool is_wallet_cash_trusted = 3;
     */
    isWalletCashTrusted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 time_all_trusted = 4;
     */
    timeAllTrusted?: number;
}
/**
 * @generated from protobuf message CMsgGCHAccountVacStatusChange
 */
export interface CMsgGCHAccountVacStatusChange {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime_vacban_starts = 3;
     */
    rtimeVacbanStarts?: number;
    /**
     * @generated from protobuf field: optional bool is_banned_now = 4;
     */
    isBannedNow?: boolean;
    /**
     * @generated from protobuf field: optional bool is_banned_future = 5;
     */
    isBannedFuture?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetPartnerAccountLink
 */
export interface CMsgGCGetPartnerAccountLink {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgGCGetPartnerAccountLink_Response
 */
export interface CMsgGCGetPartnerAccountLink_Response {
    /**
     * @generated from protobuf field: optional uint32 pwid = 1;
     */
    pwid?: number;
    /**
     * @generated from protobuf field: optional uint32 nexonid = 2;
     */
    nexonid?: number;
    /**
     * @generated from protobuf field: optional int32 ageclass = 3;
     */
    ageclass?: number;
    /**
     * @generated from protobuf field: optional bool id_verified = 4;
     */
    idVerified?: boolean;
    /**
     * @generated from protobuf field: optional bool is_adult = 5;
     */
    isAdult?: boolean;
}
/**
 * @generated from protobuf message CMsgGCRoutingInfo
 */
export interface CMsgGCRoutingInfo {
    /**
     * @generated from protobuf field: repeated uint32 dir_index = 1;
     */
    dirIndex: number[];
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod method = 2;
     */
    method?: CMsgGCRoutingInfo_RoutingMethod;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod fallback = 3;
     */
    fallback?: CMsgGCRoutingInfo_RoutingMethod;
    /**
     * @generated from protobuf field: optional uint32 protobuf_field = 4;
     */
    protobufField?: number;
    /**
     * @generated from protobuf field: optional string webapi_param = 5;
     */
    webapiParam?: string;
}
/**
 * @generated from protobuf enum CMsgGCRoutingInfo.RoutingMethod
 */
export enum CMsgGCRoutingInfo_RoutingMethod {
    /**
     * @generated from protobuf enum value: RANDOM = 0;
     */
    RANDOM = 0,
    /**
     * @generated from protobuf enum value: DISCARD = 1;
     */
    DISCARD = 1,
    /**
     * @generated from protobuf enum value: CLIENT_STEAMID = 2;
     */
    CLIENT_STEAMID = 2,
    /**
     * @generated from protobuf enum value: PROTOBUF_FIELD_UINT64 = 3;
     */
    PROTOBUF_FIELD_UINT64 = 3,
    /**
     * @generated from protobuf enum value: WEBAPI_PARAM_UINT64 = 4;
     */
    WEBAPI_PARAM_UINT64 = 4
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export interface CMsgGCMsgMasterSetWebAPIRouting {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
     */
    entries: CMsgGCMsgMasterSetWebAPIRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Entry {
    /**
     * @generated from protobuf field: optional string interface_name = 1;
     */
    interfaceName?: string;
    /**
     * @generated from protobuf field: optional string method_name = 2;
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 3;
     */
    routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export interface CMsgGCMsgMasterSetClientMsgRouting {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
     */
    entries: CMsgGCMsgMasterSetClientMsgRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Entry {
    /**
     * @generated from protobuf field: optional uint32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 2;
     */
    routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions
 */
export interface CMsgGCMsgSetOptions {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgSetOptions.Option options = 1;
     */
    options: CMsgGCMsgSetOptions_Option[];
    /**
     * @generated from protobuf field: repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
     */
    clientMsgRanges: CMsgGCMsgSetOptions_MessageRange[];
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export interface CMsgGCMsgSetOptions_MessageRange {
    /**
     * @generated from protobuf field: uint32 low = 1;
     */
    low: number;
    /**
     * @generated from protobuf field: uint32 high = 2;
     */
    high: number;
}
/**
 * @generated from protobuf enum CMsgGCMsgSetOptions.Option
 */
export enum CMsgGCMsgSetOptions_Option {
    /**
     * @generated from protobuf enum value: NOTIFY_USER_SESSIONS = 0;
     */
    NOTIFY_USER_SESSIONS = 0,
    /**
     * @generated from protobuf enum value: NOTIFY_SERVER_SESSIONS = 1;
     */
    NOTIFY_SERVER_SESSIONS = 1,
    /**
     * @generated from protobuf enum value: NOTIFY_ACHIEVEMENTS = 2;
     */
    NOTIFY_ACHIEVEMENTS = 2,
    /**
     * @generated from protobuf enum value: NOTIFY_VAC_ACTION = 3;
     */
    NOTIFY_VAC_ACTION = 3
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession
 */
export interface CMsgGCHUpdateSession {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bool online = 3;
     */
    online?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 server_steam_id = 4;
     */
    serverSteamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 server_addr = 5;
     */
    serverAddr?: number;
    /**
     * @generated from protobuf field: optional uint32 server_port = 6;
     */
    serverPort?: number;
    /**
     * @generated from protobuf field: optional uint32 os_type = 7;
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional uint32 client_addr = 8;
     */
    clientAddr?: number;
    /**
     * @generated from protobuf field: repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9;
     */
    extraFields: CMsgGCHUpdateSession_ExtraField[];
    /**
     * @generated from protobuf field: optional fixed64 owner_id = 10;
     */
    ownerId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 cm_session_sysid = 11;
     */
    cmSessionSysid?: number;
    /**
     * @generated from protobuf field: optional uint32 cm_session_identifier = 12;
     */
    cmSessionIdentifier?: number;
    /**
     * @generated from protobuf field: repeated uint32 depot_ids = 13;
     */
    depotIds: number[];
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession.ExtraField
 */
export interface CMsgGCHUpdateSession_ExtraField {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity
 */
export interface CMsgNotificationOfSuspiciousActivity {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 appid = 2;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
     */
    multipleInstances?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export interface CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    /**
     * @generated from protobuf field: optional uint32 app_instance_count = 1;
     */
    appInstanceCount?: number;
    /**
     * @generated from protobuf field: repeated fixed64 other_steamids = 2;
     */
    otherSteamids: bigint[];
}
/**
 * @generated from protobuf message CMsgDPPartnerMicroTxns
 */
export interface CMsgDPPartnerMicroTxns {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string gc_name = 2;
     */
    gcName?: string;
    /**
     * @generated from protobuf field: optional CMsgDPPartnerMicroTxns.PartnerInfo partner = 3;
     */
    partner?: CMsgDPPartnerMicroTxns_PartnerInfo;
    /**
     * @generated from protobuf field: repeated CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions = 4;
     */
    transactions: CMsgDPPartnerMicroTxns_PartnerMicroTxn[];
}
/**
 * @generated from protobuf message CMsgDPPartnerMicroTxns.PartnerMicroTxn
 */
export interface CMsgDPPartnerMicroTxns_PartnerMicroTxn {
    /**
     * @generated from protobuf field: optional uint32 init_time = 1;
     */
    initTime?: number;
    /**
     * @generated from protobuf field: optional uint32 last_update_time = 2;
     */
    lastUpdateTime?: number;
    /**
     * @generated from protobuf field: optional uint64 txn_id = 3;
     */
    txnId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 account_id = 4;
     */
    accountId?: number;
    /**
     * @generated from protobuf field: optional uint32 line_item = 5;
     */
    lineItem?: number;
    /**
     * @generated from protobuf field: optional uint64 item_id = 6;
     */
    itemId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 def_index = 7;
     */
    defIndex?: number;
    /**
     * @generated from protobuf field: optional uint64 price = 8;
     */
    price?: bigint;
    /**
     * @generated from protobuf field: optional uint64 tax = 9;
     */
    tax?: bigint;
    /**
     * @generated from protobuf field: optional uint64 price_usd = 10;
     */
    priceUsd?: bigint;
    /**
     * @generated from protobuf field: optional uint64 tax_usd = 11;
     */
    taxUsd?: bigint;
    /**
     * @generated from protobuf field: optional uint32 purchase_type = 12;
     */
    purchaseType?: number;
    /**
     * @generated from protobuf field: optional uint32 steam_txn_type = 13;
     */
    steamTxnType?: number;
    /**
     * @generated from protobuf field: optional string country_code = 14;
     */
    countryCode?: string;
    /**
     * @generated from protobuf field: optional string region_code = 15;
     */
    regionCode?: string;
    /**
     * @generated from protobuf field: optional int32 quantity = 16;
     */
    quantity?: number;
    /**
     * @generated from protobuf field: optional uint64 ref_trans_id = 17;
     */
    refTransId?: bigint;
}
/**
 * @generated from protobuf message CMsgDPPartnerMicroTxns.PartnerInfo
 */
export interface CMsgDPPartnerMicroTxns_PartnerInfo {
    /**
     * @generated from protobuf field: optional uint32 partner_id = 1;
     */
    partnerId?: number;
    /**
     * @generated from protobuf field: optional string partner_name = 2;
     */
    partnerName?: string;
    /**
     * @generated from protobuf field: optional string currency_code = 3;
     */
    currencyCode?: string;
    /**
     * @generated from protobuf field: optional string currency_name = 4;
     */
    currencyName?: string;
}
/**
 * @generated from protobuf message CMsgDPPartnerMicroTxnsResponse
 */
export interface CMsgDPPartnerMicroTxnsResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode = 2;
     */
    eerrorcode?: CMsgDPPartnerMicroTxnsResponse_EErrorCode;
}
/**
 * @generated from protobuf enum CMsgDPPartnerMicroTxnsResponse.EErrorCode
 */
export enum CMsgDPPartnerMicroTxnsResponse_EErrorCode {
    /**
     * @generated from protobuf enum value: k_MsgValid = 0;
     */
    k_MsgValid = 0,
    /**
     * @generated from protobuf enum value: k_MsgInvalidAppID = 1;
     */
    k_MsgInvalidAppID = 1,
    /**
     * @generated from protobuf enum value: k_MsgInvalidPartnerInfo = 2;
     */
    k_MsgInvalidPartnerInfo = 2,
    /**
     * @generated from protobuf enum value: k_MsgNoTransactions = 3;
     */
    k_MsgNoTransactions = 3,
    /**
     * @generated from protobuf enum value: k_MsgSQLFailure = 4;
     */
    k_MsgSQLFailure = 4,
    /**
     * @generated from protobuf enum value: k_MsgPartnerInfoDiscrepancy = 5;
     */
    k_MsgPartnerInfoDiscrepancy = 5,
    /**
     * @generated from protobuf enum value: k_MsgTransactionInsertFailed = 7;
     */
    k_MsgTransactionInsertFailed = 7,
    /**
     * @generated from protobuf enum value: k_MsgAlreadyRunning = 8;
     */
    k_MsgAlreadyRunning = 8,
    /**
     * @generated from protobuf enum value: k_MsgInvalidTransactionData = 9;
     */
    k_MsgInvalidTransactionData = 9
}
/**
 * @generated from protobuf message CChinaAgreementSessions_StartAgreementSessionInGame_Request
 */
export interface CChinaAgreementSessions_StartAgreementSessionInGame_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 2;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string client_ipaddress = 3;
     */
    clientIpaddress?: string;
}
/**
 * @generated from protobuf message CChinaAgreementSessions_StartAgreementSessionInGame_Response
 */
export interface CChinaAgreementSessions_StartAgreementSessionInGame_Response {
    /**
     * @generated from protobuf field: optional string agreement_url = 1;
     */
    agreementUrl?: string;
}
/**
 * @generated from protobuf enum GCProtoBufMsgSrc
 */
export enum GCProtoBufMsgSrc {
    /**
     * @generated from protobuf enum value: GCProtoBufMsgSrc_Unspecified = 0;
     */
    GCProtoBufMsgSrc_Unspecified = 0,
    /**
     * @generated from protobuf enum value: GCProtoBufMsgSrc_FromSystem = 1;
     */
    GCProtoBufMsgSrc_FromSystem = 1,
    /**
     * @generated from protobuf enum value: GCProtoBufMsgSrc_FromSteamID = 2;
     */
    GCProtoBufMsgSrc_FromSteamID = 2,
    /**
     * @generated from protobuf enum value: GCProtoBufMsgSrc_FromGC = 3;
     */
    GCProtoBufMsgSrc_FromGC = 3,
    /**
     * @generated from protobuf enum value: GCProtoBufMsgSrc_ReplySystem = 4;
     */
    GCProtoBufMsgSrc_ReplySystem = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgProtoBufHeader$Type extends MessageType<CMsgProtoBufHeader> {
    constructor() {
        super("CMsgProtoBufHeader", [
            { no: 1, name: "client_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "client_session_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "source_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "job_id_source", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "job_id_target", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "target_job_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 200, name: "gc_msg_src", kind: "enum", opt: true, T: () => ["GCProtoBufMsgSrc", GCProtoBufMsgSrc] },
            { no: 201, name: "gc_dir_index_source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ], { msgpool_soft_limit: 256, msgpool_hard_limit: 1024 });
    }
    create(value?: PartialMessage<CMsgProtoBufHeader>): CMsgProtoBufHeader {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgProtoBufHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgProtoBufHeader): CMsgProtoBufHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 client_steam_id */ 1:
                    message.clientSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 client_session_id */ 2:
                    message.clientSessionId = reader.int32();
                    break;
                case /* optional uint32 source_app_id */ 3:
                    message.sourceAppId = reader.uint32();
                    break;
                case /* optional fixed64 job_id_source */ 10:
                    message.jobIdSource = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 job_id_target */ 11:
                    message.jobIdTarget = reader.fixed64().toBigInt();
                    break;
                case /* optional string target_job_name */ 12:
                    message.targetJobName = reader.string();
                    break;
                case /* optional int32 eresult */ 13:
                    message.eresult = reader.int32();
                    break;
                case /* optional string error_message */ 14:
                    message.errorMessage = reader.string();
                    break;
                case /* optional uint32 ip */ 15:
                    message.ip = reader.uint32();
                    break;
                case /* optional GCProtoBufMsgSrc gc_msg_src */ 200:
                    message.gcMsgSrc = reader.int32();
                    break;
                case /* optional uint32 gc_dir_index_source */ 201:
                    message.gcDirIndexSource = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgProtoBufHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 client_steam_id = 1; */
        if (message.clientSteamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.clientSteamId);
        /* optional int32 client_session_id = 2; */
        if (message.clientSessionId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.clientSessionId);
        /* optional uint32 source_app_id = 3; */
        if (message.sourceAppId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.sourceAppId);
        /* optional fixed64 job_id_source = 10; */
        if (message.jobIdSource !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.jobIdSource);
        /* optional fixed64 job_id_target = 11; */
        if (message.jobIdTarget !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.jobIdTarget);
        /* optional string target_job_name = 12; */
        if (message.targetJobName !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.targetJobName);
        /* optional int32 eresult = 13; */
        if (message.eresult !== undefined)
            writer.tag(13, WireType.Varint).int32(message.eresult);
        /* optional string error_message = 14; */
        if (message.errorMessage !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.errorMessage);
        /* optional uint32 ip = 15; */
        if (message.ip !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.ip);
        /* optional GCProtoBufMsgSrc gc_msg_src = 200; */
        if (message.gcMsgSrc !== undefined)
            writer.tag(200, WireType.Varint).int32(message.gcMsgSrc);
        /* optional uint32 gc_dir_index_source = 201; */
        if (message.gcDirIndexSource !== undefined)
            writer.tag(201, WireType.Varint).uint32(message.gcDirIndexSource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgProtoBufHeader
 */
export const CMsgProtoBufHeader = new CMsgProtoBufHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIKey$Type extends MessageType<CMsgWebAPIKey> {
    constructor() {
        super("CMsgWebAPIKey", [
            { no: 1, name: "status", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "publisher_group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "key_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "domain", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgWebAPIKey>): CMsgWebAPIKey {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgWebAPIKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgWebAPIKey): CMsgWebAPIKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* optional uint32 account_id */ 2:
                    message.accountId = reader.uint32();
                    break;
                case /* optional uint32 publisher_group_id */ 3:
                    message.publisherGroupId = reader.uint32();
                    break;
                case /* optional uint32 key_id */ 4:
                    message.keyId = reader.uint32();
                    break;
                case /* optional string domain */ 5:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgWebAPIKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* optional uint32 account_id = 2; */
        if (message.accountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.accountId);
        /* optional uint32 publisher_group_id = 3; */
        if (message.publisherGroupId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.publisherGroupId);
        /* optional uint32 key_id = 4; */
        if (message.keyId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.keyId);
        /* optional string domain = 5; */
        if (message.domain !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIKey
 */
export const CMsgWebAPIKey = new CMsgWebAPIKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest$Type extends MessageType<CMsgHttpRequest> {
    constructor() {
        super("CMsgHttpRequest", [
            { no: 1, name: "request_method", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_RequestHeader },
            { no: 5, name: "get_params", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_QueryParam },
            { no: 6, name: "post_params", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_QueryParam },
            { no: 7, name: "body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "absolute_timeout", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest>): CMsgHttpRequest {
        const message = { headers: [], getParams: [], postParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest): CMsgHttpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 request_method */ 1:
                    message.requestMethod = reader.uint32();
                    break;
                case /* optional string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* optional string url */ 3:
                    message.url = reader.string();
                    break;
                case /* repeated CMsgHttpRequest.RequestHeader headers */ 4:
                    message.headers.push(CMsgHttpRequest_RequestHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgHttpRequest.QueryParam get_params */ 5:
                    message.getParams.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgHttpRequest.QueryParam post_params */ 6:
                    message.postParams.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes body */ 7:
                    message.body = reader.bytes();
                    break;
                case /* optional uint32 absolute_timeout */ 8:
                    message.absoluteTimeout = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 request_method = 1; */
        if (message.requestMethod !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.requestMethod);
        /* optional string hostname = 2; */
        if (message.hostname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* optional string url = 3; */
        if (message.url !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* repeated CMsgHttpRequest.RequestHeader headers = 4; */
        for (let i = 0; i < message.headers.length; i++)
            CMsgHttpRequest_RequestHeader.internalBinaryWrite(message.headers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgHttpRequest.QueryParam get_params = 5; */
        for (let i = 0; i < message.getParams.length; i++)
            CMsgHttpRequest_QueryParam.internalBinaryWrite(message.getParams[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgHttpRequest.QueryParam post_params = 6; */
        for (let i = 0; i < message.postParams.length; i++)
            CMsgHttpRequest_QueryParam.internalBinaryWrite(message.postParams[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes body = 7; */
        if (message.body !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.body);
        /* optional uint32 absolute_timeout = 8; */
        if (message.absoluteTimeout !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.absoluteTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest
 */
export const CMsgHttpRequest = new CMsgHttpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_RequestHeader$Type extends MessageType<CMsgHttpRequest_RequestHeader> {
    constructor() {
        super("CMsgHttpRequest.RequestHeader", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest_RequestHeader>): CMsgHttpRequest_RequestHeader {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest_RequestHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest_RequestHeader): CMsgHttpRequest_RequestHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest_RequestHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.RequestHeader
 */
export const CMsgHttpRequest_RequestHeader = new CMsgHttpRequest_RequestHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_QueryParam$Type extends MessageType<CMsgHttpRequest_QueryParam> {
    constructor() {
        super("CMsgHttpRequest.QueryParam", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest_QueryParam>): CMsgHttpRequest_QueryParam {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest_QueryParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest_QueryParam): CMsgHttpRequest_QueryParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest_QueryParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.QueryParam
 */
export const CMsgHttpRequest_QueryParam = new CMsgHttpRequest_QueryParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIRequest$Type extends MessageType<CMsgWebAPIRequest> {
    constructor() {
        super("CMsgWebAPIRequest", [
            { no: 1, name: "UNUSED_job_name", kind: "scalar", jsonName: "UNUSEDJobName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "interface_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "api_key", kind: "message", T: () => CMsgWebAPIKey },
            { no: 6, name: "request", kind: "message", T: () => CMsgHttpRequest },
            { no: 7, name: "routing_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgWebAPIRequest>): CMsgWebAPIRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgWebAPIRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgWebAPIRequest): CMsgWebAPIRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string UNUSED_job_name = 1 [json_name = "UNUSEDJobName"];*/ 1:
                    message.uNUSEDJobName = reader.string();
                    break;
                case /* optional string interface_name */ 2:
                    message.interfaceName = reader.string();
                    break;
                case /* optional string method_name */ 3:
                    message.methodName = reader.string();
                    break;
                case /* optional uint32 version */ 4:
                    message.version = reader.uint32();
                    break;
                case /* optional CMsgWebAPIKey api_key */ 5:
                    message.apiKey = CMsgWebAPIKey.internalBinaryRead(reader, reader.uint32(), options, message.apiKey);
                    break;
                case /* optional CMsgHttpRequest request */ 6:
                    message.request = CMsgHttpRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* optional uint32 routing_app_id */ 7:
                    message.routingAppId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgWebAPIRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string UNUSED_job_name = 1 [json_name = "UNUSEDJobName"]; */
        if (message.uNUSEDJobName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.uNUSEDJobName);
        /* optional string interface_name = 2; */
        if (message.interfaceName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.interfaceName);
        /* optional string method_name = 3; */
        if (message.methodName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.methodName);
        /* optional uint32 version = 4; */
        if (message.version !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.version);
        /* optional CMsgWebAPIKey api_key = 5; */
        if (message.apiKey)
            CMsgWebAPIKey.internalBinaryWrite(message.apiKey, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgHttpRequest request = 6; */
        if (message.request)
            CMsgHttpRequest.internalBinaryWrite(message.request, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 routing_app_id = 7; */
        if (message.routingAppId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.routingAppId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIRequest
 */
export const CMsgWebAPIRequest = new CMsgWebAPIRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse$Type extends MessageType<CMsgHttpResponse> {
    constructor() {
        super("CMsgHttpResponse", [
            { no: 1, name: "status_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpResponse_ResponseHeader },
            { no: 3, name: "body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpResponse>): CMsgHttpResponse {
        const message = { headers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpResponse): CMsgHttpResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 status_code */ 1:
                    message.statusCode = reader.uint32();
                    break;
                case /* repeated CMsgHttpResponse.ResponseHeader headers */ 2:
                    message.headers.push(CMsgHttpResponse_ResponseHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes body */ 3:
                    message.body = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 status_code = 1; */
        if (message.statusCode !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statusCode);
        /* repeated CMsgHttpResponse.ResponseHeader headers = 2; */
        for (let i = 0; i < message.headers.length; i++)
            CMsgHttpResponse_ResponseHeader.internalBinaryWrite(message.headers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes body = 3; */
        if (message.body !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse
 */
export const CMsgHttpResponse = new CMsgHttpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse_ResponseHeader$Type extends MessageType<CMsgHttpResponse_ResponseHeader> {
    constructor() {
        super("CMsgHttpResponse.ResponseHeader", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpResponse_ResponseHeader>): CMsgHttpResponse_ResponseHeader {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpResponse_ResponseHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpResponse_ResponseHeader): CMsgHttpResponse_ResponseHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpResponse_ResponseHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse.ResponseHeader
 */
export const CMsgHttpResponse_ResponseHeader = new CMsgHttpResponse_ResponseHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccounts$Type extends MessageType<CMsgAMFindAccounts> {
    constructor() {
        super("CMsgAMFindAccounts", [
            { no: 1, name: "search_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "search_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMFindAccounts>): CMsgAMFindAccounts {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMFindAccounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMFindAccounts): CMsgAMFindAccounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 search_type */ 1:
                    message.searchType = reader.uint32();
                    break;
                case /* optional string search_string */ 2:
                    message.searchString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMFindAccounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 search_type = 1; */
        if (message.searchType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.searchType);
        /* optional string search_string = 2; */
        if (message.searchString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.searchString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccounts
 */
export const CMsgAMFindAccounts = new CMsgAMFindAccounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccountsResponse$Type extends MessageType<CMsgAMFindAccountsResponse> {
    constructor() {
        super("CMsgAMFindAccountsResponse", [
            { no: 1, name: "steam_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMFindAccountsResponse>): CMsgAMFindAccountsResponse {
        const message = { steamId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMFindAccountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMFindAccountsResponse): CMsgAMFindAccountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 steam_id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamId.push(reader.fixed64().toBigInt());
                    else
                        message.steamId.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMFindAccountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 steam_id = 1; */
        for (let i = 0; i < message.steamId.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccountsResponse
 */
export const CMsgAMFindAccountsResponse = new CMsgAMFindAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotifyWatchdog$Type extends MessageType<CMsgNotifyWatchdog> {
    constructor() {
        super("CMsgNotifyWatchdog", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "alert_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "alert_destination", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "critical", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNotifyWatchdog>): CMsgNotifyWatchdog {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgNotifyWatchdog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotifyWatchdog): CMsgNotifyWatchdog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source */ 1:
                    message.source = reader.uint32();
                    break;
                case /* optional uint32 alert_type */ 2:
                    message.alertType = reader.uint32();
                    break;
                case /* optional uint32 alert_destination */ 3:
                    message.alertDestination = reader.uint32();
                    break;
                case /* optional bool critical */ 4:
                    message.critical = reader.bool();
                    break;
                case /* optional uint32 time */ 5:
                    message.time = reader.uint32();
                    break;
                case /* optional uint32 appid */ 6:
                    message.appid = reader.uint32();
                    break;
                case /* optional string text */ 7:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotifyWatchdog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.source);
        /* optional uint32 alert_type = 2; */
        if (message.alertType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.alertType);
        /* optional uint32 alert_destination = 3; */
        if (message.alertDestination !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.alertDestination);
        /* optional bool critical = 4; */
        if (message.critical !== undefined)
            writer.tag(4, WireType.Varint).bool(message.critical);
        /* optional uint32 time = 5; */
        if (message.time !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.time);
        /* optional uint32 appid = 6; */
        if (message.appid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appid);
        /* optional string text = 7; */
        if (message.text !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotifyWatchdog
 */
export const CMsgNotifyWatchdog = new CMsgNotifyWatchdog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicenses$Type extends MessageType<CMsgAMGetLicenses> {
    constructor() {
        super("CMsgAMGetLicenses", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetLicenses>): CMsgAMGetLicenses {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetLicenses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetLicenses): CMsgAMGetLicenses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetLicenses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicenses
 */
export const CMsgAMGetLicenses = new CMsgAMGetLicenses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPackageLicense$Type extends MessageType<CMsgPackageLicense> {
    constructor() {
        super("CMsgPackageLicense", [
            { no: 1, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "time_created", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgPackageLicense>): CMsgPackageLicense {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgPackageLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgPackageLicense): CMsgPackageLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_id */ 1:
                    message.packageId = reader.uint32();
                    break;
                case /* optional uint32 time_created */ 2:
                    message.timeCreated = reader.uint32();
                    break;
                case /* optional uint32 owner_id */ 3:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgPackageLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_id = 1; */
        if (message.packageId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageId);
        /* optional uint32 time_created = 2; */
        if (message.timeCreated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timeCreated);
        /* optional uint32 owner_id = 3; */
        if (message.ownerId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgPackageLicense
 */
export const CMsgPackageLicense = new CMsgPackageLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicensesResponse$Type extends MessageType<CMsgAMGetLicensesResponse> {
    constructor() {
        super("CMsgAMGetLicensesResponse", [
            { no: 1, name: "license", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgPackageLicense },
            { no: 2, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetLicensesResponse>): CMsgAMGetLicensesResponse {
        const message = { license: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetLicensesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetLicensesResponse): CMsgAMGetLicensesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgPackageLicense license */ 1:
                    message.license.push(CMsgPackageLicense.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 result */ 2:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetLicensesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgPackageLicense license = 1; */
        for (let i = 0; i < message.license.length; i++)
            CMsgPackageLicense.internalBinaryWrite(message.license[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 result = 2; */
        if (message.result !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicensesResponse
 */
export const CMsgAMGetLicensesResponse = new CMsgAMGetLicensesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetUserGameStats$Type extends MessageType<CMsgAMGetUserGameStats> {
    constructor() {
        super("CMsgAMGetUserGameStats", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "stats", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetUserGameStats>): CMsgAMGetUserGameStats {
        const message = { stats: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetUserGameStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetUserGameStats): CMsgAMGetUserGameStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 game_id */ 2:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* repeated uint32 stats */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.stats.push(reader.uint32());
                    else
                        message.stats.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetUserGameStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional fixed64 game_id = 2; */
        if (message.gameId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameId);
        /* repeated uint32 stats = 3; */
        for (let i = 0; i < message.stats.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.stats[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetUserGameStats
 */
export const CMsgAMGetUserGameStats = new CMsgAMGetUserGameStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetUserGameStatsResponse$Type extends MessageType<CMsgAMGetUserGameStatsResponse> {
    constructor() {
        super("CMsgAMGetUserGameStatsResponse", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "game_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMGetUserGameStatsResponse_Stats },
            { no: 5, name: "achievement_blocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMGetUserGameStatsResponse_Achievement_Blocks }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetUserGameStatsResponse>): CMsgAMGetUserGameStatsResponse {
        const message = { stats: [], achievementBlocks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetUserGameStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetUserGameStatsResponse): CMsgAMGetUserGameStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 game_id */ 2:
                    message.gameId = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 eresult */ 3:
                    message.eresult = reader.int32();
                    break;
                case /* repeated CMsgAMGetUserGameStatsResponse.Stats stats */ 4:
                    message.stats.push(CMsgAMGetUserGameStatsResponse_Stats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks */ 5:
                    message.achievementBlocks.push(CMsgAMGetUserGameStatsResponse_Achievement_Blocks.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetUserGameStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional fixed64 game_id = 2; */
        if (message.gameId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.gameId);
        /* optional int32 eresult = 3; */
        if (message.eresult !== undefined)
            writer.tag(3, WireType.Varint).int32(message.eresult);
        /* repeated CMsgAMGetUserGameStatsResponse.Stats stats = 4; */
        for (let i = 0; i < message.stats.length; i++)
            CMsgAMGetUserGameStatsResponse_Stats.internalBinaryWrite(message.stats[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgAMGetUserGameStatsResponse.Achievement_Blocks achievement_blocks = 5; */
        for (let i = 0; i < message.achievementBlocks.length; i++)
            CMsgAMGetUserGameStatsResponse_Achievement_Blocks.internalBinaryWrite(message.achievementBlocks[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetUserGameStatsResponse
 */
export const CMsgAMGetUserGameStatsResponse = new CMsgAMGetUserGameStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetUserGameStatsResponse_Stats$Type extends MessageType<CMsgAMGetUserGameStatsResponse_Stats> {
    constructor() {
        super("CMsgAMGetUserGameStatsResponse.Stats", [
            { no: 1, name: "stat_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stat_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetUserGameStatsResponse_Stats>): CMsgAMGetUserGameStatsResponse_Stats {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetUserGameStatsResponse_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetUserGameStatsResponse_Stats): CMsgAMGetUserGameStatsResponse_Stats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 stat_id */ 1:
                    message.statId = reader.uint32();
                    break;
                case /* optional uint32 stat_value */ 2:
                    message.statValue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetUserGameStatsResponse_Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 stat_id = 1; */
        if (message.statId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statId);
        /* optional uint32 stat_value = 2; */
        if (message.statValue !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.statValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetUserGameStatsResponse.Stats
 */
export const CMsgAMGetUserGameStatsResponse_Stats = new CMsgAMGetUserGameStatsResponse_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetUserGameStatsResponse_Achievement_Blocks$Type extends MessageType<CMsgAMGetUserGameStatsResponse_Achievement_Blocks> {
    constructor() {
        super("CMsgAMGetUserGameStatsResponse.Achievement_Blocks", [
            { no: 1, name: "achievement_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "achievement_bit_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "unlock_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetUserGameStatsResponse_Achievement_Blocks>): CMsgAMGetUserGameStatsResponse_Achievement_Blocks {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetUserGameStatsResponse_Achievement_Blocks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetUserGameStatsResponse_Achievement_Blocks): CMsgAMGetUserGameStatsResponse_Achievement_Blocks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 achievement_id */ 1:
                    message.achievementId = reader.uint32();
                    break;
                case /* optional uint32 achievement_bit_id */ 2:
                    message.achievementBitId = reader.uint32();
                    break;
                case /* optional fixed32 unlock_time */ 3:
                    message.unlockTime = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetUserGameStatsResponse_Achievement_Blocks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 achievement_id = 1; */
        if (message.achievementId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.achievementId);
        /* optional uint32 achievement_bit_id = 2; */
        if (message.achievementBitId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.achievementBitId);
        /* optional fixed32 unlock_time = 3; */
        if (message.unlockTime !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.unlockTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetUserGameStatsResponse.Achievement_Blocks
 */
export const CMsgAMGetUserGameStatsResponse_Achievement_Blocks = new CMsgAMGetUserGameStatsResponse_Achievement_Blocks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandList$Type extends MessageType<CMsgGCGetCommandList> {
    constructor() {
        super("CMsgGCGetCommandList", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "command_prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetCommandList>): CMsgGCGetCommandList {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetCommandList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetCommandList): CMsgGCGetCommandList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string command_prefix */ 2:
                    message.commandPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetCommandList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string command_prefix = 2; */
        if (message.commandPrefix !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.commandPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandList
 */
export const CMsgGCGetCommandList = new CMsgGCGetCommandList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandListResponse$Type extends MessageType<CMsgGCGetCommandListResponse> {
    constructor() {
        super("CMsgGCGetCommandListResponse", [
            { no: 1, name: "command_name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetCommandListResponse>): CMsgGCGetCommandListResponse {
        const message = { commandName: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetCommandListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetCommandListResponse): CMsgGCGetCommandListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string command_name */ 1:
                    message.commandName.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetCommandListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string command_name = 1; */
        for (let i = 0; i < message.commandName.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.commandName[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandListResponse
 */
export const CMsgGCGetCommandListResponse = new CMsgGCGetCommandListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGet$Type extends MessageType<CGCMsgMemCachedGet> {
    constructor() {
        super("CGCMsgMemCachedGet", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGet>): CGCMsgMemCachedGet {
        const message = { keys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGet): CGCMsgMemCachedGet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGet
 */
export const CGCMsgMemCachedGet = new CGCMsgMemCachedGet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse$Type extends MessageType<CGCMsgMemCachedGetResponse> {
    constructor() {
        super("CGCMsgMemCachedGetResponse", [
            { no: 1, name: "values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCMsgMemCachedGetResponse_ValueTag }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGetResponse>): CGCMsgMemCachedGetResponse {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGetResponse): CGCMsgMemCachedGetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGCMsgMemCachedGetResponse.ValueTag values */ 1:
                    message.values.push(CGCMsgMemCachedGetResponse_ValueTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGCMsgMemCachedGetResponse.ValueTag values = 1; */
        for (let i = 0; i < message.values.length; i++)
            CGCMsgMemCachedGetResponse_ValueTag.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse
 */
export const CGCMsgMemCachedGetResponse = new CGCMsgMemCachedGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse_ValueTag$Type extends MessageType<CGCMsgMemCachedGetResponse_ValueTag> {
    constructor() {
        super("CGCMsgMemCachedGetResponse.ValueTag", [
            { no: 1, name: "found", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGetResponse_ValueTag>): CGCMsgMemCachedGetResponse_ValueTag {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGetResponse_ValueTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGetResponse_ValueTag): CGCMsgMemCachedGetResponse_ValueTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool found */ 1:
                    message.found = reader.bool();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGetResponse_ValueTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool found = 1; */
        if (message.found !== undefined)
            writer.tag(1, WireType.Varint).bool(message.found);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export const CGCMsgMemCachedGetResponse_ValueTag = new CGCMsgMemCachedGetResponse_ValueTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet$Type extends MessageType<CGCMsgMemCachedSet> {
    constructor() {
        super("CGCMsgMemCachedSet", [
            { no: 1, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCMsgMemCachedSet_KeyPair }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedSet>): CGCMsgMemCachedSet {
        const message = { keys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedSet): CGCMsgMemCachedSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGCMsgMemCachedSet.KeyPair keys */ 1:
                    message.keys.push(CGCMsgMemCachedSet_KeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGCMsgMemCachedSet.KeyPair keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            CGCMsgMemCachedSet_KeyPair.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet
 */
export const CGCMsgMemCachedSet = new CGCMsgMemCachedSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet_KeyPair$Type extends MessageType<CGCMsgMemCachedSet_KeyPair> {
    constructor() {
        super("CGCMsgMemCachedSet.KeyPair", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedSet_KeyPair>): CGCMsgMemCachedSet_KeyPair {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedSet_KeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedSet_KeyPair): CGCMsgMemCachedSet_KeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedSet_KeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet.KeyPair
 */
export const CGCMsgMemCachedSet_KeyPair = new CGCMsgMemCachedSet_KeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedDelete$Type extends MessageType<CGCMsgMemCachedDelete> {
    constructor() {
        super("CGCMsgMemCachedDelete", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedDelete>): CGCMsgMemCachedDelete {
        const message = { keys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedDelete): CGCMsgMemCachedDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedDelete
 */
export const CGCMsgMemCachedDelete = new CGCMsgMemCachedDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStats$Type extends MessageType<CGCMsgMemCachedStats> {
    constructor() {
        super("CGCMsgMemCachedStats", []);
    }
    create(value?: PartialMessage<CGCMsgMemCachedStats>): CGCMsgMemCachedStats {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedStats): CGCMsgMemCachedStats {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CGCMsgMemCachedStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStats
 */
export const CGCMsgMemCachedStats = new CGCMsgMemCachedStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStatsResponse$Type extends MessageType<CGCMsgMemCachedStatsResponse> {
    constructor() {
        super("CGCMsgMemCachedStatsResponse", [
            { no: 1, name: "curr_connections", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cmd_get", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "cmd_set", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "cmd_flush", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "get_hits", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "get_misses", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "delete_hits", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "delete_misses", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "bytes_read", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "bytes_written", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "limit_maxbytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "curr_items", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "evictions", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedStatsResponse>): CGCMsgMemCachedStatsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedStatsResponse): CGCMsgMemCachedStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 curr_connections */ 1:
                    message.currConnections = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_get */ 2:
                    message.cmdGet = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_set */ 3:
                    message.cmdSet = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_flush */ 4:
                    message.cmdFlush = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 get_hits */ 5:
                    message.getHits = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 get_misses */ 6:
                    message.getMisses = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 delete_hits */ 7:
                    message.deleteHits = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 delete_misses */ 8:
                    message.deleteMisses = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_read */ 9:
                    message.bytesRead = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_written */ 10:
                    message.bytesWritten = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 limit_maxbytes */ 11:
                    message.limitMaxbytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 curr_items */ 12:
                    message.currItems = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 evictions */ 13:
                    message.evictions = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes */ 14:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 curr_connections = 1; */
        if (message.currConnections !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.currConnections);
        /* optional uint64 cmd_get = 2; */
        if (message.cmdGet !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.cmdGet);
        /* optional uint64 cmd_set = 3; */
        if (message.cmdSet !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.cmdSet);
        /* optional uint64 cmd_flush = 4; */
        if (message.cmdFlush !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.cmdFlush);
        /* optional uint64 get_hits = 5; */
        if (message.getHits !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.getHits);
        /* optional uint64 get_misses = 6; */
        if (message.getMisses !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.getMisses);
        /* optional uint64 delete_hits = 7; */
        if (message.deleteHits !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.deleteHits);
        /* optional uint64 delete_misses = 8; */
        if (message.deleteMisses !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.deleteMisses);
        /* optional uint64 bytes_read = 9; */
        if (message.bytesRead !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.bytesRead);
        /* optional uint64 bytes_written = 10; */
        if (message.bytesWritten !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.bytesWritten);
        /* optional uint64 limit_maxbytes = 11; */
        if (message.limitMaxbytes !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.limitMaxbytes);
        /* optional uint64 curr_items = 12; */
        if (message.currItems !== undefined)
            writer.tag(12, WireType.Varint).uint64(message.currItems);
        /* optional uint64 evictions = 13; */
        if (message.evictions !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.evictions);
        /* optional uint64 bytes = 14; */
        if (message.bytes !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStatsResponse
 */
export const CGCMsgMemCachedStatsResponse = new CGCMsgMemCachedStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStats$Type extends MessageType<CGCMsgSQLStats> {
    constructor() {
        super("CGCMsgSQLStats", [
            { no: 1, name: "schema_catalog", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgSQLStats>): CGCMsgSQLStats {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgSQLStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgSQLStats): CGCMsgSQLStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 schema_catalog */ 1:
                    message.schemaCatalog = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgSQLStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 schema_catalog = 1; */
        if (message.schemaCatalog !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.schemaCatalog);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStats
 */
export const CGCMsgSQLStats = new CGCMsgSQLStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStatsResponse$Type extends MessageType<CGCMsgSQLStatsResponse> {
    constructor() {
        super("CGCMsgSQLStatsResponse", [
            { no: 1, name: "threads", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "threads_connected", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "threads_active", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "operations_submitted", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "prepared_statements_executed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "non_prepared_statements_executed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "deadlock_retries", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "operations_timed_out_in_queue", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "errors", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgSQLStatsResponse>): CGCMsgSQLStatsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgSQLStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgSQLStatsResponse): CGCMsgSQLStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 threads */ 1:
                    message.threads = reader.uint32();
                    break;
                case /* optional uint32 threads_connected */ 2:
                    message.threadsConnected = reader.uint32();
                    break;
                case /* optional uint32 threads_active */ 3:
                    message.threadsActive = reader.uint32();
                    break;
                case /* optional uint32 operations_submitted */ 4:
                    message.operationsSubmitted = reader.uint32();
                    break;
                case /* optional uint32 prepared_statements_executed */ 5:
                    message.preparedStatementsExecuted = reader.uint32();
                    break;
                case /* optional uint32 non_prepared_statements_executed */ 6:
                    message.nonPreparedStatementsExecuted = reader.uint32();
                    break;
                case /* optional uint32 deadlock_retries */ 7:
                    message.deadlockRetries = reader.uint32();
                    break;
                case /* optional uint32 operations_timed_out_in_queue */ 8:
                    message.operationsTimedOutInQueue = reader.uint32();
                    break;
                case /* optional uint32 errors */ 9:
                    message.errors = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgSQLStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 threads = 1; */
        if (message.threads !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.threads);
        /* optional uint32 threads_connected = 2; */
        if (message.threadsConnected !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.threadsConnected);
        /* optional uint32 threads_active = 3; */
        if (message.threadsActive !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.threadsActive);
        /* optional uint32 operations_submitted = 4; */
        if (message.operationsSubmitted !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.operationsSubmitted);
        /* optional uint32 prepared_statements_executed = 5; */
        if (message.preparedStatementsExecuted !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.preparedStatementsExecuted);
        /* optional uint32 non_prepared_statements_executed = 6; */
        if (message.nonPreparedStatementsExecuted !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.nonPreparedStatementsExecuted);
        /* optional uint32 deadlock_retries = 7; */
        if (message.deadlockRetries !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.deadlockRetries);
        /* optional uint32 operations_timed_out_in_queue = 8; */
        if (message.operationsTimedOutInQueue !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.operationsTimedOutInQueue);
        /* optional uint32 errors = 9; */
        if (message.errors !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.errors);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStatsResponse
 */
export const CGCMsgSQLStatsResponse = new CGCMsgSQLStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicense$Type extends MessageType<CMsgAMAddFreeLicense> {
    constructor() {
        super("CMsgAMAddFreeLicense", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ip_public", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "store_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMAddFreeLicense>): CMsgAMAddFreeLicense {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMAddFreeLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMAddFreeLicense): CMsgAMAddFreeLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 ip_public */ 2:
                    message.ipPublic = reader.uint32();
                    break;
                case /* optional uint32 packageid */ 3:
                    message.packageid = reader.uint32();
                    break;
                case /* optional string store_country_code */ 4:
                    message.storeCountryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMAddFreeLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 ip_public = 2; */
        if (message.ipPublic !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ipPublic);
        /* optional uint32 packageid = 3; */
        if (message.packageid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.packageid);
        /* optional string store_country_code = 4; */
        if (message.storeCountryCode !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.storeCountryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicense
 */
export const CMsgAMAddFreeLicense = new CMsgAMAddFreeLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicenseResponse$Type extends MessageType<CMsgAMAddFreeLicenseResponse> {
    constructor() {
        super("CMsgAMAddFreeLicenseResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "purchase_result_detail", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "transid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMAddFreeLicenseResponse>): CMsgAMAddFreeLicenseResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMAddFreeLicenseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMAddFreeLicenseResponse): CMsgAMAddFreeLicenseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 purchase_result_detail */ 2:
                    message.purchaseResultDetail = reader.int32();
                    break;
                case /* optional fixed64 transid */ 3:
                    message.transid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMAddFreeLicenseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 purchase_result_detail = 2; */
        if (message.purchaseResultDetail !== undefined)
            writer.tag(2, WireType.Varint).int32(message.purchaseResultDetail);
        /* optional fixed64 transid = 3; */
        if (message.transid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.transid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicenseResponse
 */
export const CMsgAMAddFreeLicenseResponse = new CMsgAMAddFreeLicenseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPLocation$Type extends MessageType<CGCMsgGetIPLocation> {
    constructor() {
        super("CGCMsgGetIPLocation", [
            { no: 1, name: "ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetIPLocation>): CGCMsgGetIPLocation {
        const message = { ips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetIPLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetIPLocation): CGCMsgGetIPLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 ips */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ips.push(reader.fixed32());
                    else
                        message.ips.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetIPLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 ips = 1; */
        for (let i = 0; i < message.ips.length; i++)
            writer.tag(1, WireType.Bit32).fixed32(message.ips[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPLocation
 */
export const CGCMsgGetIPLocation = new CGCMsgGetIPLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CIPLocationInfo$Type extends MessageType<CIPLocationInfo> {
    constructor() {
        super("CIPLocationInfo", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "latitude", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "longitude", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "country", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "city", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CIPLocationInfo>): CIPLocationInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CIPLocationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CIPLocationInfo): CIPLocationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 ip */ 1:
                    message.ip = reader.uint32();
                    break;
                case /* optional float latitude */ 2:
                    message.latitude = reader.float();
                    break;
                case /* optional float longitude */ 3:
                    message.longitude = reader.float();
                    break;
                case /* optional string country */ 4:
                    message.country = reader.string();
                    break;
                case /* optional string state */ 5:
                    message.state = reader.string();
                    break;
                case /* optional string city */ 6:
                    message.city = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CIPLocationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 ip = 1; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.ip);
        /* optional float latitude = 2; */
        if (message.latitude !== undefined)
            writer.tag(2, WireType.Bit32).float(message.latitude);
        /* optional float longitude = 3; */
        if (message.longitude !== undefined)
            writer.tag(3, WireType.Bit32).float(message.longitude);
        /* optional string country = 4; */
        if (message.country !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.country);
        /* optional string state = 5; */
        if (message.state !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.state);
        /* optional string city = 6; */
        if (message.city !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.city);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CIPLocationInfo
 */
export const CIPLocationInfo = new CIPLocationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPLocationResponse$Type extends MessageType<CGCMsgGetIPLocationResponse> {
    constructor() {
        super("CGCMsgGetIPLocationResponse", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CIPLocationInfo }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetIPLocationResponse>): CGCMsgGetIPLocationResponse {
        const message = { infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetIPLocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetIPLocationResponse): CGCMsgGetIPLocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CIPLocationInfo infos */ 1:
                    message.infos.push(CIPLocationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetIPLocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CIPLocationInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            CIPLocationInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPLocationResponse
 */
export const CGCMsgGetIPLocationResponse = new CGCMsgGetIPLocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSystemStatsSchema$Type extends MessageType<CGCMsgSystemStatsSchema> {
    constructor() {
        super("CGCMsgSystemStatsSchema", [
            { no: 1, name: "gc_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "schema_kv", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgSystemStatsSchema>): CGCMsgSystemStatsSchema {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgSystemStatsSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgSystemStatsSchema): CGCMsgSystemStatsSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 gc_app_id */ 1:
                    message.gcAppId = reader.uint32();
                    break;
                case /* optional bytes schema_kv */ 2:
                    message.schemaKv = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgSystemStatsSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 gc_app_id = 1; */
        if (message.gcAppId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.gcAppId);
        /* optional bytes schema_kv = 2; */
        if (message.schemaKv !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.schemaKv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgSystemStatsSchema
 */
export const CGCMsgSystemStatsSchema = new CGCMsgSystemStatsSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetSystemStats$Type extends MessageType<CGCMsgGetSystemStats> {
    constructor() {
        super("CGCMsgGetSystemStats", []);
    }
    create(value?: PartialMessage<CGCMsgGetSystemStats>): CGCMsgGetSystemStats {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetSystemStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetSystemStats): CGCMsgGetSystemStats {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CGCMsgGetSystemStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetSystemStats
 */
export const CGCMsgGetSystemStats = new CGCMsgGetSystemStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetSystemStatsResponse$Type extends MessageType<CGCMsgGetSystemStatsResponse> {
    constructor() {
        super("CGCMsgGetSystemStatsResponse", [
            { no: 1, name: "gc_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stats_kv", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "active_jobs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "yielding_jobs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "user_sessions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "game_server_sessions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "socaches", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "socaches_to_unload", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "socaches_loading", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "writeback_queue", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "steamid_locks", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "logon_queue", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "logon_jobs", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetSystemStatsResponse>): CGCMsgGetSystemStatsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetSystemStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetSystemStatsResponse): CGCMsgGetSystemStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 gc_app_id */ 1:
                    message.gcAppId = reader.uint32();
                    break;
                case /* optional bytes stats_kv */ 2:
                    message.statsKv = reader.bytes();
                    break;
                case /* optional uint32 active_jobs */ 3:
                    message.activeJobs = reader.uint32();
                    break;
                case /* optional uint32 yielding_jobs */ 4:
                    message.yieldingJobs = reader.uint32();
                    break;
                case /* optional uint32 user_sessions */ 5:
                    message.userSessions = reader.uint32();
                    break;
                case /* optional uint32 game_server_sessions */ 6:
                    message.gameServerSessions = reader.uint32();
                    break;
                case /* optional uint32 socaches */ 7:
                    message.socaches = reader.uint32();
                    break;
                case /* optional uint32 socaches_to_unload */ 8:
                    message.socachesToUnload = reader.uint32();
                    break;
                case /* optional uint32 socaches_loading */ 9:
                    message.socachesLoading = reader.uint32();
                    break;
                case /* optional uint32 writeback_queue */ 10:
                    message.writebackQueue = reader.uint32();
                    break;
                case /* optional uint32 steamid_locks */ 11:
                    message.steamidLocks = reader.uint32();
                    break;
                case /* optional uint32 logon_queue */ 12:
                    message.logonQueue = reader.uint32();
                    break;
                case /* optional uint32 logon_jobs */ 13:
                    message.logonJobs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetSystemStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 gc_app_id = 1; */
        if (message.gcAppId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.gcAppId);
        /* optional bytes stats_kv = 2; */
        if (message.statsKv !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.statsKv);
        /* optional uint32 active_jobs = 3; */
        if (message.activeJobs !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.activeJobs);
        /* optional uint32 yielding_jobs = 4; */
        if (message.yieldingJobs !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.yieldingJobs);
        /* optional uint32 user_sessions = 5; */
        if (message.userSessions !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.userSessions);
        /* optional uint32 game_server_sessions = 6; */
        if (message.gameServerSessions !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.gameServerSessions);
        /* optional uint32 socaches = 7; */
        if (message.socaches !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.socaches);
        /* optional uint32 socaches_to_unload = 8; */
        if (message.socachesToUnload !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.socachesToUnload);
        /* optional uint32 socaches_loading = 9; */
        if (message.socachesLoading !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.socachesLoading);
        /* optional uint32 writeback_queue = 10; */
        if (message.writebackQueue !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.writebackQueue);
        /* optional uint32 steamid_locks = 11; */
        if (message.steamidLocks !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.steamidLocks);
        /* optional uint32 logon_queue = 12; */
        if (message.logonQueue !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.logonQueue);
        /* optional uint32 logon_jobs = 13; */
        if (message.logonJobs !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.logonJobs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetSystemStatsResponse
 */
export const CGCMsgGetSystemStatsResponse = new CGCMsgGetSystemStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail$Type extends MessageType<CMsgAMSendEmail> {
    constructor() {
        super("CMsgAMSendEmail", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "email_msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "email_format", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "persona_name_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMSendEmail_PersonaNameReplacementToken },
            { no: 6, name: "source_gc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMSendEmail_ReplacementToken }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail>): CMsgAMSendEmail {
        const message = { personaNameTokens: [], tokens: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail): CMsgAMSendEmail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 email_msg_type */ 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case /* optional uint32 email_format */ 3:
                    message.emailFormat = reader.uint32();
                    break;
                case /* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens */ 5:
                    message.personaNameTokens.push(CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 source_gc */ 6:
                    message.sourceGc = reader.uint32();
                    break;
                case /* repeated CMsgAMSendEmail.ReplacementToken tokens */ 7:
                    message.tokens.push(CMsgAMSendEmail_ReplacementToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 email_msg_type = 2; */
        if (message.emailMsgType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.emailMsgType);
        /* optional uint32 email_format = 3; */
        if (message.emailFormat !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.emailFormat);
        /* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5; */
        for (let i = 0; i < message.personaNameTokens.length; i++)
            CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryWrite(message.personaNameTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 source_gc = 6; */
        if (message.sourceGc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.sourceGc);
        /* repeated CMsgAMSendEmail.ReplacementToken tokens = 7; */
        for (let i = 0; i < message.tokens.length; i++)
            CMsgAMSendEmail_ReplacementToken.internalBinaryWrite(message.tokens[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail
 */
export const CMsgAMSendEmail = new CMsgAMSendEmail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_ReplacementToken$Type extends MessageType<CMsgAMSendEmail_ReplacementToken> {
    constructor() {
        super("CMsgAMSendEmail.ReplacementToken", [
            { no: 1, name: "token_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail_ReplacementToken>): CMsgAMSendEmail_ReplacementToken {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail_ReplacementToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail_ReplacementToken): CMsgAMSendEmail_ReplacementToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token_name */ 1:
                    message.tokenName = reader.string();
                    break;
                case /* optional string token_value */ 2:
                    message.tokenValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail_ReplacementToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token_name = 1; */
        if (message.tokenName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tokenName);
        /* optional string token_value = 2; */
        if (message.tokenValue !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tokenValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.ReplacementToken
 */
export const CMsgAMSendEmail_ReplacementToken = new CMsgAMSendEmail_ReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_PersonaNameReplacementToken$Type extends MessageType<CMsgAMSendEmail_PersonaNameReplacementToken> {
    constructor() {
        super("CMsgAMSendEmail.PersonaNameReplacementToken", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail_PersonaNameReplacementToken>): CMsgAMSendEmail_PersonaNameReplacementToken {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail_PersonaNameReplacementToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail_PersonaNameReplacementToken): CMsgAMSendEmail_PersonaNameReplacementToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string token_name */ 2:
                    message.tokenName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail_PersonaNameReplacementToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string token_name = 2; */
        if (message.tokenName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tokenName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export const CMsgAMSendEmail_PersonaNameReplacementToken = new CMsgAMSendEmail_PersonaNameReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmailResponse$Type extends MessageType<CMsgAMSendEmailResponse> {
    constructor() {
        super("CMsgAMSendEmailResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmailResponse>): CMsgAMSendEmailResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmailResponse): CMsgAMSendEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmailResponse
 */
export const CMsgAMSendEmailResponse = new CMsgAMSendEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplate$Type extends MessageType<CMsgGCGetEmailTemplate> {
    constructor() {
        super("CMsgGCGetEmailTemplate", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "email_msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "email_lang", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "email_format", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetEmailTemplate>): CMsgGCGetEmailTemplate {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetEmailTemplate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetEmailTemplate): CMsgGCGetEmailTemplate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 email_msg_type */ 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case /* optional int32 email_lang */ 3:
                    message.emailLang = reader.int32();
                    break;
                case /* optional int32 email_format */ 4:
                    message.emailFormat = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetEmailTemplate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 email_msg_type = 2; */
        if (message.emailMsgType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.emailMsgType);
        /* optional int32 email_lang = 3; */
        if (message.emailLang !== undefined)
            writer.tag(3, WireType.Varint).int32(message.emailLang);
        /* optional int32 email_format = 4; */
        if (message.emailFormat !== undefined)
            writer.tag(4, WireType.Varint).int32(message.emailFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplate
 */
export const CMsgGCGetEmailTemplate = new CMsgGCGetEmailTemplate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplateResponse$Type extends MessageType<CMsgGCGetEmailTemplateResponse> {
    constructor() {
        super("CMsgGCGetEmailTemplateResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "template_exists", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "template", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetEmailTemplateResponse>): CMsgGCGetEmailTemplateResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetEmailTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetEmailTemplateResponse): CMsgGCGetEmailTemplateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional bool template_exists */ 2:
                    message.templateExists = reader.bool();
                    break;
                case /* optional string template */ 3:
                    message.template = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetEmailTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional bool template_exists = 2; */
        if (message.templateExists !== undefined)
            writer.tag(2, WireType.Varint).bool(message.templateExists);
        /* optional string template = 3; */
        if (message.template !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.template);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplateResponse
 */
export const CMsgGCGetEmailTemplateResponse = new CMsgGCGetEmailTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2$Type extends MessageType<CMsgAMGrantGuestPasses2> {
    constructor() {
        super("CMsgAMGrantGuestPasses2", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "passes_to_grant", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "days_to_expiration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGrantGuestPasses2>): CMsgAMGrantGuestPasses2 {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGrantGuestPasses2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGrantGuestPasses2): CMsgAMGrantGuestPasses2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 package_id */ 2:
                    message.packageId = reader.uint32();
                    break;
                case /* optional int32 passes_to_grant */ 3:
                    message.passesToGrant = reader.int32();
                    break;
                case /* optional int32 days_to_expiration */ 4:
                    message.daysToExpiration = reader.int32();
                    break;
                case /* optional int32 action */ 5:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGrantGuestPasses2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 package_id = 2; */
        if (message.packageId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.packageId);
        /* optional int32 passes_to_grant = 3; */
        if (message.passesToGrant !== undefined)
            writer.tag(3, WireType.Varint).int32(message.passesToGrant);
        /* optional int32 days_to_expiration = 4; */
        if (message.daysToExpiration !== undefined)
            writer.tag(4, WireType.Varint).int32(message.daysToExpiration);
        /* optional int32 action = 5; */
        if (message.action !== undefined)
            writer.tag(5, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2
 */
export const CMsgAMGrantGuestPasses2 = new CMsgAMGrantGuestPasses2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2Response$Type extends MessageType<CMsgAMGrantGuestPasses2Response> {
    constructor() {
        super("CMsgAMGrantGuestPasses2Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "passes_granted", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGrantGuestPasses2Response>): CMsgAMGrantGuestPasses2Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGrantGuestPasses2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGrantGuestPasses2Response): CMsgAMGrantGuestPasses2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 passes_granted */ 2:
                    message.passesGranted = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGrantGuestPasses2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 passes_granted = 2; */
        if (message.passesGranted !== undefined)
            writer.tag(2, WireType.Varint).int32(message.passesGranted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2Response
 */
export const CMsgAMGrantGuestPasses2Response = new CMsgAMGrantGuestPasses2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetAccountDetails$Type extends MessageType<CGCSystemMsg_GetAccountDetails> {
    constructor() {
        super("CGCSystemMsg_GetAccountDetails", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ], { msgpool_soft_limit: 128, msgpool_hard_limit: 512 });
    }
    create(value?: PartialMessage<CGCSystemMsg_GetAccountDetails>): CGCSystemMsg_GetAccountDetails {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetAccountDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetAccountDetails): CGCSystemMsg_GetAccountDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetAccountDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetAccountDetails
 */
export const CGCSystemMsg_GetAccountDetails = new CGCSystemMsg_GetAccountDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetAccountDetails_Response$Type extends MessageType<CGCSystemMsg_GetAccountDetails_Response> {
    constructor() {
        super("CGCSystemMsg_GetAccountDetails_Response", [
            { no: 1, name: "eresult_deprecated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "account_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_profile_public", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_inventory_public", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_vac_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "is_cyber_cafe", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "is_school_account", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_limited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "is_subscribed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "package", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "is_free_trial_account", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "free_trial_expiration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "is_low_violence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "is_account_locked_down", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_community_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "is_trade_banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "trade_ban_expiration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "suspension_end_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "currency", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "steam_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "friend_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "account_creation_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "is_steamguard_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "is_phone_verified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "is_two_factor_auth_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "two_factor_enabled_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "phone_verification_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "phone_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 34, name: "is_phone_identifying", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 35, name: "rt_identity_linked", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 36, name: "rt_birth_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 37, name: "txn_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "has_accepted_china_ssa", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "is_banned_steam_china", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ], { msgpool_soft_limit: 128, msgpool_hard_limit: 512 });
    }
    create(value?: PartialMessage<CGCSystemMsg_GetAccountDetails_Response>): CGCSystemMsg_GetAccountDetails_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetAccountDetails_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetAccountDetails_Response): CGCSystemMsg_GetAccountDetails_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult_deprecated */ 1:
                    message.eresultDeprecated = reader.uint32();
                    break;
                case /* optional string account_name */ 2:
                    message.accountName = reader.string();
                    break;
                case /* optional string persona_name */ 3:
                    message.personaName = reader.string();
                    break;
                case /* optional bool is_profile_public */ 4:
                    message.isProfilePublic = reader.bool();
                    break;
                case /* optional bool is_inventory_public */ 5:
                    message.isInventoryPublic = reader.bool();
                    break;
                case /* optional bool is_vac_banned */ 7:
                    message.isVacBanned = reader.bool();
                    break;
                case /* optional bool is_cyber_cafe */ 8:
                    message.isCyberCafe = reader.bool();
                    break;
                case /* optional bool is_school_account */ 9:
                    message.isSchoolAccount = reader.bool();
                    break;
                case /* optional bool is_limited */ 10:
                    message.isLimited = reader.bool();
                    break;
                case /* optional bool is_subscribed */ 11:
                    message.isSubscribed = reader.bool();
                    break;
                case /* optional uint32 package */ 12:
                    message.package = reader.uint32();
                    break;
                case /* optional bool is_free_trial_account */ 13:
                    message.isFreeTrialAccount = reader.bool();
                    break;
                case /* optional uint32 free_trial_expiration */ 14:
                    message.freeTrialExpiration = reader.uint32();
                    break;
                case /* optional bool is_low_violence */ 15:
                    message.isLowViolence = reader.bool();
                    break;
                case /* optional bool is_account_locked_down */ 16:
                    message.isAccountLockedDown = reader.bool();
                    break;
                case /* optional bool is_community_banned */ 17:
                    message.isCommunityBanned = reader.bool();
                    break;
                case /* optional bool is_trade_banned */ 18:
                    message.isTradeBanned = reader.bool();
                    break;
                case /* optional uint32 trade_ban_expiration */ 19:
                    message.tradeBanExpiration = reader.uint32();
                    break;
                case /* optional uint32 accountid */ 20:
                    message.accountid = reader.uint32();
                    break;
                case /* optional uint32 suspension_end_time */ 21:
                    message.suspensionEndTime = reader.uint32();
                    break;
                case /* optional string currency */ 22:
                    message.currency = reader.string();
                    break;
                case /* optional uint32 steam_level */ 23:
                    message.steamLevel = reader.uint32();
                    break;
                case /* optional uint32 friend_count */ 24:
                    message.friendCount = reader.uint32();
                    break;
                case /* optional uint32 account_creation_time */ 25:
                    message.accountCreationTime = reader.uint32();
                    break;
                case /* optional bool is_steamguard_enabled */ 27:
                    message.isSteamguardEnabled = reader.bool();
                    break;
                case /* optional bool is_phone_verified */ 28:
                    message.isPhoneVerified = reader.bool();
                    break;
                case /* optional bool is_two_factor_auth_enabled */ 29:
                    message.isTwoFactorAuthEnabled = reader.bool();
                    break;
                case /* optional uint32 two_factor_enabled_time */ 30:
                    message.twoFactorEnabledTime = reader.uint32();
                    break;
                case /* optional uint32 phone_verification_time */ 31:
                    message.phoneVerificationTime = reader.uint32();
                    break;
                case /* optional uint64 phone_id */ 33:
                    message.phoneId = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_phone_identifying */ 34:
                    message.isPhoneIdentifying = reader.bool();
                    break;
                case /* optional uint32 rt_identity_linked */ 35:
                    message.rtIdentityLinked = reader.uint32();
                    break;
                case /* optional uint32 rt_birth_date */ 36:
                    message.rtBirthDate = reader.uint32();
                    break;
                case /* optional string txn_country_code */ 37:
                    message.txnCountryCode = reader.string();
                    break;
                case /* optional bool has_accepted_china_ssa */ 38:
                    message.hasAcceptedChinaSsa = reader.bool();
                    break;
                case /* optional bool is_banned_steam_china */ 39:
                    message.isBannedSteamChina = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetAccountDetails_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult_deprecated = 1; */
        if (message.eresultDeprecated !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresultDeprecated);
        /* optional string account_name = 2; */
        if (message.accountName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accountName);
        /* optional string persona_name = 3; */
        if (message.personaName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.personaName);
        /* optional bool is_profile_public = 4; */
        if (message.isProfilePublic !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isProfilePublic);
        /* optional bool is_inventory_public = 5; */
        if (message.isInventoryPublic !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isInventoryPublic);
        /* optional bool is_vac_banned = 7; */
        if (message.isVacBanned !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isVacBanned);
        /* optional bool is_cyber_cafe = 8; */
        if (message.isCyberCafe !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isCyberCafe);
        /* optional bool is_school_account = 9; */
        if (message.isSchoolAccount !== undefined)
            writer.tag(9, WireType.Varint).bool(message.isSchoolAccount);
        /* optional bool is_limited = 10; */
        if (message.isLimited !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isLimited);
        /* optional bool is_subscribed = 11; */
        if (message.isSubscribed !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isSubscribed);
        /* optional uint32 package = 12; */
        if (message.package !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.package);
        /* optional bool is_free_trial_account = 13; */
        if (message.isFreeTrialAccount !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isFreeTrialAccount);
        /* optional uint32 free_trial_expiration = 14; */
        if (message.freeTrialExpiration !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.freeTrialExpiration);
        /* optional bool is_low_violence = 15; */
        if (message.isLowViolence !== undefined)
            writer.tag(15, WireType.Varint).bool(message.isLowViolence);
        /* optional bool is_account_locked_down = 16; */
        if (message.isAccountLockedDown !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isAccountLockedDown);
        /* optional bool is_community_banned = 17; */
        if (message.isCommunityBanned !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isCommunityBanned);
        /* optional bool is_trade_banned = 18; */
        if (message.isTradeBanned !== undefined)
            writer.tag(18, WireType.Varint).bool(message.isTradeBanned);
        /* optional uint32 trade_ban_expiration = 19; */
        if (message.tradeBanExpiration !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.tradeBanExpiration);
        /* optional uint32 accountid = 20; */
        if (message.accountid !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.accountid);
        /* optional uint32 suspension_end_time = 21; */
        if (message.suspensionEndTime !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.suspensionEndTime);
        /* optional string currency = 22; */
        if (message.currency !== undefined)
            writer.tag(22, WireType.LengthDelimited).string(message.currency);
        /* optional uint32 steam_level = 23; */
        if (message.steamLevel !== undefined)
            writer.tag(23, WireType.Varint).uint32(message.steamLevel);
        /* optional uint32 friend_count = 24; */
        if (message.friendCount !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.friendCount);
        /* optional uint32 account_creation_time = 25; */
        if (message.accountCreationTime !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.accountCreationTime);
        /* optional bool is_steamguard_enabled = 27; */
        if (message.isSteamguardEnabled !== undefined)
            writer.tag(27, WireType.Varint).bool(message.isSteamguardEnabled);
        /* optional bool is_phone_verified = 28; */
        if (message.isPhoneVerified !== undefined)
            writer.tag(28, WireType.Varint).bool(message.isPhoneVerified);
        /* optional bool is_two_factor_auth_enabled = 29; */
        if (message.isTwoFactorAuthEnabled !== undefined)
            writer.tag(29, WireType.Varint).bool(message.isTwoFactorAuthEnabled);
        /* optional uint32 two_factor_enabled_time = 30; */
        if (message.twoFactorEnabledTime !== undefined)
            writer.tag(30, WireType.Varint).uint32(message.twoFactorEnabledTime);
        /* optional uint32 phone_verification_time = 31; */
        if (message.phoneVerificationTime !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.phoneVerificationTime);
        /* optional uint64 phone_id = 33; */
        if (message.phoneId !== undefined)
            writer.tag(33, WireType.Varint).uint64(message.phoneId);
        /* optional bool is_phone_identifying = 34; */
        if (message.isPhoneIdentifying !== undefined)
            writer.tag(34, WireType.Varint).bool(message.isPhoneIdentifying);
        /* optional uint32 rt_identity_linked = 35; */
        if (message.rtIdentityLinked !== undefined)
            writer.tag(35, WireType.Varint).uint32(message.rtIdentityLinked);
        /* optional uint32 rt_birth_date = 36; */
        if (message.rtBirthDate !== undefined)
            writer.tag(36, WireType.Varint).uint32(message.rtBirthDate);
        /* optional string txn_country_code = 37; */
        if (message.txnCountryCode !== undefined)
            writer.tag(37, WireType.LengthDelimited).string(message.txnCountryCode);
        /* optional bool has_accepted_china_ssa = 38; */
        if (message.hasAcceptedChinaSsa !== undefined)
            writer.tag(38, WireType.Varint).bool(message.hasAcceptedChinaSsa);
        /* optional bool is_banned_steam_china = 39; */
        if (message.isBannedSteamChina !== undefined)
            writer.tag(39, WireType.Varint).bool(message.isBannedSteamChina);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetAccountDetails_Response
 */
export const CGCSystemMsg_GetAccountDetails_Response = new CGCSystemMsg_GetAccountDetails_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames$Type extends MessageType<CMsgGCGetPersonaNames> {
    constructor() {
        super("CMsgGCGetPersonaNames", [
            { no: 1, name: "steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames>): CMsgGCGetPersonaNames {
        const message = { steamids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames): CMsgGCGetPersonaNames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 steamids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamids.push(reader.fixed64().toBigInt());
                    else
                        message.steamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 steamids = 1; */
        for (let i = 0; i < message.steamids.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.steamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames
 */
export const CMsgGCGetPersonaNames = new CMsgGCGetPersonaNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response$Type extends MessageType<CMsgGCGetPersonaNames_Response> {
    constructor() {
        super("CMsgGCGetPersonaNames_Response", [
            { no: 1, name: "succeeded_lookups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCGetPersonaNames_Response_PersonaName },
            { no: 2, name: "failed_lookup_steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames_Response>): CMsgGCGetPersonaNames_Response {
        const message = { succeededLookups: [], failedLookupSteamids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames_Response): CMsgGCGetPersonaNames_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups */ 1:
                    message.succeededLookups.push(CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated fixed64 failed_lookup_steamids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.failedLookupSteamids.push(reader.fixed64().toBigInt());
                    else
                        message.failedLookupSteamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1; */
        for (let i = 0; i < message.succeededLookups.length; i++)
            CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryWrite(message.succeededLookups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed64 failed_lookup_steamids = 2; */
        for (let i = 0; i < message.failedLookupSteamids.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.failedLookupSteamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response
 */
export const CMsgGCGetPersonaNames_Response = new CMsgGCGetPersonaNames_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response_PersonaName$Type extends MessageType<CMsgGCGetPersonaNames_Response_PersonaName> {
    constructor() {
        super("CMsgGCGetPersonaNames_Response.PersonaName", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames_Response_PersonaName>): CMsgGCGetPersonaNames_Response_PersonaName {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames_Response_PersonaName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames_Response_PersonaName): CMsgGCGetPersonaNames_Response_PersonaName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 2:
                    message.personaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames_Response_PersonaName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string persona_name = 2; */
        if (message.personaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.personaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export const CMsgGCGetPersonaNames_Response_PersonaName = new CMsgGCGetPersonaNames_Response_PersonaName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship$Type extends MessageType<CMsgGCCheckFriendship> {
    constructor() {
        super("CMsgGCCheckFriendship", [
            { no: 1, name: "steamid_left", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steamid_right", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckFriendship>): CMsgGCCheckFriendship {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckFriendship>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckFriendship): CMsgGCCheckFriendship {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_left */ 1:
                    message.steamidLeft = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steamid_right */ 2:
                    message.steamidRight = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckFriendship, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_left = 1; */
        if (message.steamidLeft !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidLeft);
        /* optional fixed64 steamid_right = 2; */
        if (message.steamidRight !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidRight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship
 */
export const CMsgGCCheckFriendship = new CMsgGCCheckFriendship$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship_Response$Type extends MessageType<CMsgGCCheckFriendship_Response> {
    constructor() {
        super("CMsgGCCheckFriendship_Response", [
            { no: 1, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "found_friendship", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckFriendship_Response>): CMsgGCCheckFriendship_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckFriendship_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckFriendship_Response): CMsgGCCheckFriendship_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* optional bool found_friendship */ 2:
                    message.foundFriendship = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckFriendship_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool success = 1; */
        if (message.success !== undefined)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* optional bool found_friendship = 2; */
        if (message.foundFriendship !== undefined)
            writer.tag(2, WireType.Varint).bool(message.foundFriendship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship_Response
 */
export const CMsgGCCheckFriendship_Response = new CMsgGCCheckFriendship_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory$Type extends MessageType<CMsgGCMsgMasterSetDirectory> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory", [
            { no: 1, name: "master_dir_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "dir", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetDirectory_SubGC }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory>): CMsgGCMsgMasterSetDirectory {
        const message = { dir: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory): CMsgGCMsgMasterSetDirectory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 master_dir_index */ 1:
                    message.masterDirIndex = reader.uint32();
                    break;
                case /* repeated CMsgGCMsgMasterSetDirectory.SubGC dir */ 2:
                    message.dir.push(CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 master_dir_index = 1; */
        if (message.masterDirIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.masterDirIndex);
        /* repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2; */
        for (let i = 0; i < message.dir.length; i++)
            CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryWrite(message.dir[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory
 */
export const CMsgGCMsgMasterSetDirectory = new CMsgGCMsgMasterSetDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_SubGC$Type extends MessageType<CMsgGCMsgMasterSetDirectory_SubGC> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory.SubGC", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "box", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "command_line", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gc_binary", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_SubGC>): CMsgGCMsgMasterSetDirectory_SubGC {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory_SubGC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory_SubGC): CMsgGCMsgMasterSetDirectory_SubGC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 dir_index */ 1:
                    message.dirIndex = reader.uint32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string box */ 3:
                    message.box = reader.string();
                    break;
                case /* optional string command_line */ 4:
                    message.commandLine = reader.string();
                    break;
                case /* optional string gc_binary */ 5:
                    message.gcBinary = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory_SubGC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dirIndex);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string box = 3; */
        if (message.box !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.box);
        /* optional string command_line = 4; */
        if (message.commandLine !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.commandLine);
        /* optional string gc_binary = 5; */
        if (message.gcBinary !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.gcBinary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export const CMsgGCMsgMasterSetDirectory_SubGC = new CMsgGCMsgMasterSetDirectory_SubGC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_Response$Type extends MessageType<CMsgGCMsgMasterSetDirectory_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_Response>): CMsgGCMsgMasterSetDirectory_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory_Response): CMsgGCMsgMasterSetDirectory_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional string message = 2; */
        if (message.message !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export const CMsgGCMsgMasterSetDirectory_Response = new CMsgGCMsgMasterSetDirectory_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgWebAPIJobRequestForwardResponse$Type extends MessageType<CMsgGCMsgWebAPIJobRequestForwardResponse> {
    constructor() {
        super("CMsgGCMsgWebAPIJobRequestForwardResponse", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgWebAPIJobRequestForwardResponse>): CMsgGCMsgWebAPIJobRequestForwardResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgWebAPIJobRequestForwardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgWebAPIJobRequestForwardResponse): CMsgGCMsgWebAPIJobRequestForwardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 dir_index */ 1:
                    message.dirIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgWebAPIJobRequestForwardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dirIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export const CMsgGCMsgWebAPIJobRequestForwardResponse = new CMsgGCMsgWebAPIJobRequestForwardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Request$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Request> {
    constructor() {
        super("CGCSystemMsg_GetPurchaseTrust_Request", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Request>): CGCSystemMsg_GetPurchaseTrust_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetPurchaseTrust_Request): CGCSystemMsg_GetPurchaseTrust_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetPurchaseTrust_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export const CGCSystemMsg_GetPurchaseTrust_Request = new CGCSystemMsg_GetPurchaseTrust_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Response$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Response> {
    constructor() {
        super("CGCSystemMsg_GetPurchaseTrust_Response", [
            { no: 1, name: "has_prior_purchase_history", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "has_no_recent_password_resets", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_wallet_cash_trusted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "time_all_trusted", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Response>): CGCSystemMsg_GetPurchaseTrust_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetPurchaseTrust_Response): CGCSystemMsg_GetPurchaseTrust_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool has_prior_purchase_history */ 1:
                    message.hasPriorPurchaseHistory = reader.bool();
                    break;
                case /* optional bool has_no_recent_password_resets */ 2:
                    message.hasNoRecentPasswordResets = reader.bool();
                    break;
                case /* optional bool is_wallet_cash_trusted */ 3:
                    message.isWalletCashTrusted = reader.bool();
                    break;
                case /* optional uint32 time_all_trusted */ 4:
                    message.timeAllTrusted = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetPurchaseTrust_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool has_prior_purchase_history = 1; */
        if (message.hasPriorPurchaseHistory !== undefined)
            writer.tag(1, WireType.Varint).bool(message.hasPriorPurchaseHistory);
        /* optional bool has_no_recent_password_resets = 2; */
        if (message.hasNoRecentPasswordResets !== undefined)
            writer.tag(2, WireType.Varint).bool(message.hasNoRecentPasswordResets);
        /* optional bool is_wallet_cash_trusted = 3; */
        if (message.isWalletCashTrusted !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isWalletCashTrusted);
        /* optional uint32 time_all_trusted = 4; */
        if (message.timeAllTrusted !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.timeAllTrusted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export const CGCSystemMsg_GetPurchaseTrust_Response = new CGCSystemMsg_GetPurchaseTrust_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAccountVacStatusChange$Type extends MessageType<CMsgGCHAccountVacStatusChange> {
    constructor() {
        super("CMsgGCHAccountVacStatusChange", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "rtime_vacban_starts", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_banned_now", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_banned_future", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAccountVacStatusChange>): CMsgGCHAccountVacStatusChange {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAccountVacStatusChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAccountVacStatusChange): CMsgGCHAccountVacStatusChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 rtime_vacban_starts */ 3:
                    message.rtimeVacbanStarts = reader.uint32();
                    break;
                case /* optional bool is_banned_now */ 4:
                    message.isBannedNow = reader.bool();
                    break;
                case /* optional bool is_banned_future */ 5:
                    message.isBannedFuture = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAccountVacStatusChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 rtime_vacban_starts = 3; */
        if (message.rtimeVacbanStarts !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.rtimeVacbanStarts);
        /* optional bool is_banned_now = 4; */
        if (message.isBannedNow !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isBannedNow);
        /* optional bool is_banned_future = 5; */
        if (message.isBannedFuture !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isBannedFuture);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAccountVacStatusChange
 */
export const CMsgGCHAccountVacStatusChange = new CMsgGCHAccountVacStatusChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPartnerAccountLink$Type extends MessageType<CMsgGCGetPartnerAccountLink> {
    constructor() {
        super("CMsgGCGetPartnerAccountLink", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPartnerAccountLink>): CMsgGCGetPartnerAccountLink {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPartnerAccountLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPartnerAccountLink): CMsgGCGetPartnerAccountLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPartnerAccountLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPartnerAccountLink
 */
export const CMsgGCGetPartnerAccountLink = new CMsgGCGetPartnerAccountLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPartnerAccountLink_Response$Type extends MessageType<CMsgGCGetPartnerAccountLink_Response> {
    constructor() {
        super("CMsgGCGetPartnerAccountLink_Response", [
            { no: 1, name: "pwid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nexonid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "ageclass", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "id_verified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_adult", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPartnerAccountLink_Response>): CMsgGCGetPartnerAccountLink_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPartnerAccountLink_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPartnerAccountLink_Response): CMsgGCGetPartnerAccountLink_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 pwid */ 1:
                    message.pwid = reader.uint32();
                    break;
                case /* optional uint32 nexonid */ 2:
                    message.nexonid = reader.uint32();
                    break;
                case /* optional int32 ageclass */ 3:
                    message.ageclass = reader.int32();
                    break;
                case /* optional bool id_verified */ 4:
                    message.idVerified = reader.bool();
                    break;
                case /* optional bool is_adult */ 5:
                    message.isAdult = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPartnerAccountLink_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 pwid = 1; */
        if (message.pwid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.pwid);
        /* optional uint32 nexonid = 2; */
        if (message.nexonid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.nexonid);
        /* optional int32 ageclass = 3; */
        if (message.ageclass !== undefined)
            writer.tag(3, WireType.Varint).int32(message.ageclass);
        /* optional bool id_verified = 4; */
        if (message.idVerified !== undefined)
            writer.tag(4, WireType.Varint).bool(message.idVerified);
        /* optional bool is_adult = 5; */
        if (message.isAdult !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isAdult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPartnerAccountLink_Response
 */
export const CMsgGCGetPartnerAccountLink_Response = new CMsgGCGetPartnerAccountLink_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRoutingInfo$Type extends MessageType<CMsgGCRoutingInfo> {
    constructor() {
        super("CMsgGCRoutingInfo", [
            { no: 1, name: "dir_index", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "method", kind: "enum", opt: true, T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod] },
            { no: 3, name: "fallback", kind: "enum", opt: true, T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod] },
            { no: 4, name: "protobuf_field", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "webapi_param", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCRoutingInfo>): CMsgGCRoutingInfo {
        const message = { dirIndex: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCRoutingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCRoutingInfo): CMsgGCRoutingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 dir_index */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dirIndex.push(reader.uint32());
                    else
                        message.dirIndex.push(reader.uint32());
                    break;
                case /* optional CMsgGCRoutingInfo.RoutingMethod method */ 2:
                    message.method = reader.int32();
                    break;
                case /* optional CMsgGCRoutingInfo.RoutingMethod fallback */ 3:
                    message.fallback = reader.int32();
                    break;
                case /* optional uint32 protobuf_field */ 4:
                    message.protobufField = reader.uint32();
                    break;
                case /* optional string webapi_param */ 5:
                    message.webapiParam = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCRoutingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 dir_index = 1; */
        for (let i = 0; i < message.dirIndex.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.dirIndex[i]);
        /* optional CMsgGCRoutingInfo.RoutingMethod method = 2; */
        if (message.method !== undefined)
            writer.tag(2, WireType.Varint).int32(message.method);
        /* optional CMsgGCRoutingInfo.RoutingMethod fallback = 3; */
        if (message.fallback !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fallback);
        /* optional uint32 protobuf_field = 4; */
        if (message.protobufField !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.protobufField);
        /* optional string webapi_param = 5; */
        if (message.webapiParam !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.webapiParam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCRoutingInfo
 */
export const CMsgGCRoutingInfo = new CMsgGCRoutingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetWebAPIRouting_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting>): CMsgGCMsgMasterSetWebAPIRouting {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting): CMsgGCMsgMasterSetWebAPIRouting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries */ 1:
                    message.entries.push(CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export const CMsgGCMsgMasterSetWebAPIRouting = new CMsgGCMsgMasterSetWebAPIRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Entry> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting.Entry", [
            { no: 1, name: "interface_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Entry>): CMsgGCMsgMasterSetWebAPIRouting_Entry {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting_Entry): CMsgGCMsgMasterSetWebAPIRouting_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string interface_name */ 1:
                    message.interfaceName = reader.string();
                    break;
                case /* optional string method_name */ 2:
                    message.methodName = reader.string();
                    break;
                case /* optional CMsgGCRoutingInfo routing */ 3:
                    message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string interface_name = 1; */
        if (message.interfaceName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.interfaceName);
        /* optional string method_name = 2; */
        if (message.methodName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.methodName);
        /* optional CMsgGCRoutingInfo routing = 3; */
        if (message.routing)
            CMsgGCRoutingInfo.internalBinaryWrite(message.routing, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Entry = new CMsgGCMsgMasterSetWebAPIRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetClientMsgRouting_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting>): CMsgGCMsgMasterSetClientMsgRouting {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting): CMsgGCMsgMasterSetClientMsgRouting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries */ 1:
                    message.entries.push(CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export const CMsgGCMsgMasterSetClientMsgRouting = new CMsgGCMsgMasterSetClientMsgRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Entry> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting.Entry", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Entry>): CMsgGCMsgMasterSetClientMsgRouting_Entry {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting_Entry): CMsgGCMsgMasterSetClientMsgRouting_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_type */ 1:
                    message.msgType = reader.uint32();
                    break;
                case /* optional CMsgGCRoutingInfo routing */ 2:
                    message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgType);
        /* optional CMsgGCRoutingInfo routing = 2; */
        if (message.routing)
            CMsgGCRoutingInfo.internalBinaryWrite(message.routing, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Entry = new CMsgGCMsgMasterSetClientMsgRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Response>): CMsgGCMsgMasterSetWebAPIRouting_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting_Response): CMsgGCMsgMasterSetWebAPIRouting_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Response = new CMsgGCMsgMasterSetWebAPIRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Response>): CMsgGCMsgMasterSetClientMsgRouting_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting_Response): CMsgGCMsgMasterSetClientMsgRouting_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Response = new CMsgGCMsgMasterSetClientMsgRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions$Type extends MessageType<CMsgGCMsgSetOptions> {
    constructor() {
        super("CMsgGCMsgSetOptions", [
            { no: 1, name: "options", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["CMsgGCMsgSetOptions.Option", CMsgGCMsgSetOptions_Option] },
            { no: 2, name: "client_msg_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgSetOptions_MessageRange }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgSetOptions>): CMsgGCMsgSetOptions {
        const message = { options: [], clientMsgRanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgSetOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgSetOptions): CMsgGCMsgSetOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgSetOptions.Option options */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.options.push(reader.int32());
                    else
                        message.options.push(reader.int32());
                    break;
                case /* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges */ 2:
                    message.clientMsgRanges.push(CMsgGCMsgSetOptions_MessageRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgSetOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgSetOptions.Option options = 1; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(1, WireType.Varint).int32(message.options[i]);
        /* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2; */
        for (let i = 0; i < message.clientMsgRanges.length; i++)
            CMsgGCMsgSetOptions_MessageRange.internalBinaryWrite(message.clientMsgRanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions
 */
export const CMsgGCMsgSetOptions = new CMsgGCMsgSetOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions_MessageRange$Type extends MessageType<CMsgGCMsgSetOptions_MessageRange> {
    constructor() {
        super("CMsgGCMsgSetOptions.MessageRange", [
            { no: 1, name: "low", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "high", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgSetOptions_MessageRange>): CMsgGCMsgSetOptions_MessageRange {
        const message = { low: 0, high: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgSetOptions_MessageRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgSetOptions_MessageRange): CMsgGCMsgSetOptions_MessageRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 low */ 1:
                    message.low = reader.uint32();
                    break;
                case /* uint32 high */ 2:
                    message.high = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgSetOptions_MessageRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 low = 1; */
        if (message.low !== 0)
            writer.tag(1, WireType.Varint).uint32(message.low);
        /* uint32 high = 2; */
        if (message.high !== 0)
            writer.tag(2, WireType.Varint).uint32(message.high);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export const CMsgGCMsgSetOptions_MessageRange = new CMsgGCMsgSetOptions_MessageRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession$Type extends MessageType<CMsgGCHUpdateSession> {
    constructor() {
        super("CMsgGCHUpdateSession", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "online", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "server_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "server_addr", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "os_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "client_addr", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "extra_fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCHUpdateSession_ExtraField },
            { no: 10, name: "owner_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "cm_session_sysid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "cm_session_identifier", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "depot_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHUpdateSession>): CMsgGCHUpdateSession {
        const message = { extraFields: [], depotIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHUpdateSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHUpdateSession): CMsgGCHUpdateSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bool online */ 3:
                    message.online = reader.bool();
                    break;
                case /* optional fixed64 server_steam_id */ 4:
                    message.serverSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 server_addr */ 5:
                    message.serverAddr = reader.uint32();
                    break;
                case /* optional uint32 server_port */ 6:
                    message.serverPort = reader.uint32();
                    break;
                case /* optional uint32 os_type */ 7:
                    message.osType = reader.uint32();
                    break;
                case /* optional uint32 client_addr */ 8:
                    message.clientAddr = reader.uint32();
                    break;
                case /* repeated CMsgGCHUpdateSession.ExtraField extra_fields */ 9:
                    message.extraFields.push(CMsgGCHUpdateSession_ExtraField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional fixed64 owner_id */ 10:
                    message.ownerId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 cm_session_sysid */ 11:
                    message.cmSessionSysid = reader.uint32();
                    break;
                case /* optional uint32 cm_session_identifier */ 12:
                    message.cmSessionIdentifier = reader.uint32();
                    break;
                case /* repeated uint32 depot_ids */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depotIds.push(reader.uint32());
                    else
                        message.depotIds.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHUpdateSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bool online = 3; */
        if (message.online !== undefined)
            writer.tag(3, WireType.Varint).bool(message.online);
        /* optional fixed64 server_steam_id = 4; */
        if (message.serverSteamId !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.serverSteamId);
        /* optional uint32 server_addr = 5; */
        if (message.serverAddr !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.serverAddr);
        /* optional uint32 server_port = 6; */
        if (message.serverPort !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.serverPort);
        /* optional uint32 os_type = 7; */
        if (message.osType !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.osType);
        /* optional uint32 client_addr = 8; */
        if (message.clientAddr !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.clientAddr);
        /* repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9; */
        for (let i = 0; i < message.extraFields.length; i++)
            CMsgGCHUpdateSession_ExtraField.internalBinaryWrite(message.extraFields[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 owner_id = 10; */
        if (message.ownerId !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.ownerId);
        /* optional uint32 cm_session_sysid = 11; */
        if (message.cmSessionSysid !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.cmSessionSysid);
        /* optional uint32 cm_session_identifier = 12; */
        if (message.cmSessionIdentifier !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.cmSessionIdentifier);
        /* repeated uint32 depot_ids = 13; */
        for (let i = 0; i < message.depotIds.length; i++)
            writer.tag(13, WireType.Varint).uint32(message.depotIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession
 */
export const CMsgGCHUpdateSession = new CMsgGCHUpdateSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession_ExtraField$Type extends MessageType<CMsgGCHUpdateSession_ExtraField> {
    constructor() {
        super("CMsgGCHUpdateSession.ExtraField", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHUpdateSession_ExtraField>): CMsgGCHUpdateSession_ExtraField {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHUpdateSession_ExtraField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHUpdateSession_ExtraField): CMsgGCHUpdateSession_ExtraField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHUpdateSession_ExtraField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession.ExtraField
 */
export const CMsgGCHUpdateSession_ExtraField = new CMsgGCHUpdateSession_ExtraField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity$Type extends MessageType<CMsgNotificationOfSuspiciousActivity> {
    constructor() {
        super("CMsgNotificationOfSuspiciousActivity", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "multiple_instances", kind: "message", T: () => CMsgNotificationOfSuspiciousActivity_MultipleGameInstances }
        ]);
    }
    create(value?: PartialMessage<CMsgNotificationOfSuspiciousActivity>): CMsgNotificationOfSuspiciousActivity {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgNotificationOfSuspiciousActivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotificationOfSuspiciousActivity): CMsgNotificationOfSuspiciousActivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances */ 3:
                    message.multipleInstances = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryRead(reader, reader.uint32(), options, message.multipleInstances);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotificationOfSuspiciousActivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3; */
        if (message.multipleInstances)
            CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryWrite(message.multipleInstances, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity
 */
export const CMsgNotificationOfSuspiciousActivity = new CMsgNotificationOfSuspiciousActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type extends MessageType<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances> {
    constructor() {
        super("CMsgNotificationOfSuspiciousActivity.MultipleGameInstances", [
            { no: 1, name: "app_instance_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "other_steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
        const message = { otherSteamids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_instance_count */ 1:
                    message.appInstanceCount = reader.uint32();
                    break;
                case /* repeated fixed64 other_steamids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.otherSteamids.push(reader.fixed64().toBigInt());
                    else
                        message.otherSteamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_instance_count = 1; */
        if (message.appInstanceCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appInstanceCount);
        /* repeated fixed64 other_steamids = 2; */
        for (let i = 0; i < message.otherSteamids.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.otherSteamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances = new CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPPartnerMicroTxns$Type extends MessageType<CMsgDPPartnerMicroTxns> {
    constructor() {
        super("CMsgDPPartnerMicroTxns", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gc_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "partner", kind: "message", T: () => CMsgDPPartnerMicroTxns_PartnerInfo },
            { no: 4, name: "transactions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgDPPartnerMicroTxns_PartnerMicroTxn }
        ]);
    }
    create(value?: PartialMessage<CMsgDPPartnerMicroTxns>): CMsgDPPartnerMicroTxns {
        const message = { transactions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgDPPartnerMicroTxns>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPPartnerMicroTxns): CMsgDPPartnerMicroTxns {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string gc_name */ 2:
                    message.gcName = reader.string();
                    break;
                case /* optional CMsgDPPartnerMicroTxns.PartnerInfo partner */ 3:
                    message.partner = CMsgDPPartnerMicroTxns_PartnerInfo.internalBinaryRead(reader, reader.uint32(), options, message.partner);
                    break;
                case /* repeated CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions */ 4:
                    message.transactions.push(CMsgDPPartnerMicroTxns_PartnerMicroTxn.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPPartnerMicroTxns, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string gc_name = 2; */
        if (message.gcName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gcName);
        /* optional CMsgDPPartnerMicroTxns.PartnerInfo partner = 3; */
        if (message.partner)
            CMsgDPPartnerMicroTxns_PartnerInfo.internalBinaryWrite(message.partner, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgDPPartnerMicroTxns.PartnerMicroTxn transactions = 4; */
        for (let i = 0; i < message.transactions.length; i++)
            CMsgDPPartnerMicroTxns_PartnerMicroTxn.internalBinaryWrite(message.transactions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPPartnerMicroTxns
 */
export const CMsgDPPartnerMicroTxns = new CMsgDPPartnerMicroTxns$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPPartnerMicroTxns_PartnerMicroTxn$Type extends MessageType<CMsgDPPartnerMicroTxns_PartnerMicroTxn> {
    constructor() {
        super("CMsgDPPartnerMicroTxns.PartnerMicroTxn", [
            { no: 1, name: "init_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "last_update_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "txn_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "line_item", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "item_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "def_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "price", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "tax", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "price_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "tax_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "purchase_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "steam_txn_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "region_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "quantity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "ref_trans_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDPPartnerMicroTxns_PartnerMicroTxn>): CMsgDPPartnerMicroTxns_PartnerMicroTxn {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgDPPartnerMicroTxns_PartnerMicroTxn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPPartnerMicroTxns_PartnerMicroTxn): CMsgDPPartnerMicroTxns_PartnerMicroTxn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 init_time */ 1:
                    message.initTime = reader.uint32();
                    break;
                case /* optional uint32 last_update_time */ 2:
                    message.lastUpdateTime = reader.uint32();
                    break;
                case /* optional uint64 txn_id */ 3:
                    message.txnId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 account_id */ 4:
                    message.accountId = reader.uint32();
                    break;
                case /* optional uint32 line_item */ 5:
                    message.lineItem = reader.uint32();
                    break;
                case /* optional uint64 item_id */ 6:
                    message.itemId = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 def_index */ 7:
                    message.defIndex = reader.uint32();
                    break;
                case /* optional uint64 price */ 8:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 tax */ 9:
                    message.tax = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 price_usd */ 10:
                    message.priceUsd = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 tax_usd */ 11:
                    message.taxUsd = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 purchase_type */ 12:
                    message.purchaseType = reader.uint32();
                    break;
                case /* optional uint32 steam_txn_type */ 13:
                    message.steamTxnType = reader.uint32();
                    break;
                case /* optional string country_code */ 14:
                    message.countryCode = reader.string();
                    break;
                case /* optional string region_code */ 15:
                    message.regionCode = reader.string();
                    break;
                case /* optional int32 quantity */ 16:
                    message.quantity = reader.int32();
                    break;
                case /* optional uint64 ref_trans_id */ 17:
                    message.refTransId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPPartnerMicroTxns_PartnerMicroTxn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 init_time = 1; */
        if (message.initTime !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.initTime);
        /* optional uint32 last_update_time = 2; */
        if (message.lastUpdateTime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lastUpdateTime);
        /* optional uint64 txn_id = 3; */
        if (message.txnId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.txnId);
        /* optional uint32 account_id = 4; */
        if (message.accountId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.accountId);
        /* optional uint32 line_item = 5; */
        if (message.lineItem !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.lineItem);
        /* optional uint64 item_id = 6; */
        if (message.itemId !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.itemId);
        /* optional uint32 def_index = 7; */
        if (message.defIndex !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.defIndex);
        /* optional uint64 price = 8; */
        if (message.price !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.price);
        /* optional uint64 tax = 9; */
        if (message.tax !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.tax);
        /* optional uint64 price_usd = 10; */
        if (message.priceUsd !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.priceUsd);
        /* optional uint64 tax_usd = 11; */
        if (message.taxUsd !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.taxUsd);
        /* optional uint32 purchase_type = 12; */
        if (message.purchaseType !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.purchaseType);
        /* optional uint32 steam_txn_type = 13; */
        if (message.steamTxnType !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.steamTxnType);
        /* optional string country_code = 14; */
        if (message.countryCode !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.countryCode);
        /* optional string region_code = 15; */
        if (message.regionCode !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.regionCode);
        /* optional int32 quantity = 16; */
        if (message.quantity !== undefined)
            writer.tag(16, WireType.Varint).int32(message.quantity);
        /* optional uint64 ref_trans_id = 17; */
        if (message.refTransId !== undefined)
            writer.tag(17, WireType.Varint).uint64(message.refTransId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPPartnerMicroTxns.PartnerMicroTxn
 */
export const CMsgDPPartnerMicroTxns_PartnerMicroTxn = new CMsgDPPartnerMicroTxns_PartnerMicroTxn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPPartnerMicroTxns_PartnerInfo$Type extends MessageType<CMsgDPPartnerMicroTxns_PartnerInfo> {
    constructor() {
        super("CMsgDPPartnerMicroTxns.PartnerInfo", [
            { no: 1, name: "partner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "partner_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "currency_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgDPPartnerMicroTxns_PartnerInfo>): CMsgDPPartnerMicroTxns_PartnerInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgDPPartnerMicroTxns_PartnerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPPartnerMicroTxns_PartnerInfo): CMsgDPPartnerMicroTxns_PartnerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 partner_id */ 1:
                    message.partnerId = reader.uint32();
                    break;
                case /* optional string partner_name */ 2:
                    message.partnerName = reader.string();
                    break;
                case /* optional string currency_code */ 3:
                    message.currencyCode = reader.string();
                    break;
                case /* optional string currency_name */ 4:
                    message.currencyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPPartnerMicroTxns_PartnerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 partner_id = 1; */
        if (message.partnerId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.partnerId);
        /* optional string partner_name = 2; */
        if (message.partnerName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.partnerName);
        /* optional string currency_code = 3; */
        if (message.currencyCode !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.currencyCode);
        /* optional string currency_name = 4; */
        if (message.currencyName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.currencyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPPartnerMicroTxns.PartnerInfo
 */
export const CMsgDPPartnerMicroTxns_PartnerInfo = new CMsgDPPartnerMicroTxns_PartnerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDPPartnerMicroTxnsResponse$Type extends MessageType<CMsgDPPartnerMicroTxnsResponse> {
    constructor() {
        super("CMsgDPPartnerMicroTxnsResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "eerrorcode", kind: "enum", opt: true, T: () => ["CMsgDPPartnerMicroTxnsResponse.EErrorCode", CMsgDPPartnerMicroTxnsResponse_EErrorCode] }
        ]);
    }
    create(value?: PartialMessage<CMsgDPPartnerMicroTxnsResponse>): CMsgDPPartnerMicroTxnsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgDPPartnerMicroTxnsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgDPPartnerMicroTxnsResponse): CMsgDPPartnerMicroTxnsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode */ 2:
                    message.eerrorcode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgDPPartnerMicroTxnsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional CMsgDPPartnerMicroTxnsResponse.EErrorCode eerrorcode = 2; */
        if (message.eerrorcode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eerrorcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgDPPartnerMicroTxnsResponse
 */
export const CMsgDPPartnerMicroTxnsResponse = new CMsgDPPartnerMicroTxnsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChinaAgreementSessions_StartAgreementSessionInGame_Request$Type extends MessageType<CChinaAgreementSessions_StartAgreementSessionInGame_Request> {
    constructor() {
        super("CChinaAgreementSessions_StartAgreementSessionInGame_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "client_ipaddress", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CChinaAgreementSessions_StartAgreementSessionInGame_Request>): CChinaAgreementSessions_StartAgreementSessionInGame_Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CChinaAgreementSessions_StartAgreementSessionInGame_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChinaAgreementSessions_StartAgreementSessionInGame_Request): CChinaAgreementSessions_StartAgreementSessionInGame_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional fixed64 steamid */ 2:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string client_ipaddress */ 3:
                    message.clientIpaddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChinaAgreementSessions_StartAgreementSessionInGame_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional fixed64 steamid = 2; */
        if (message.steamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamid);
        /* optional string client_ipaddress = 3; */
        if (message.clientIpaddress !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.clientIpaddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChinaAgreementSessions_StartAgreementSessionInGame_Request
 */
export const CChinaAgreementSessions_StartAgreementSessionInGame_Request = new CChinaAgreementSessions_StartAgreementSessionInGame_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CChinaAgreementSessions_StartAgreementSessionInGame_Response$Type extends MessageType<CChinaAgreementSessions_StartAgreementSessionInGame_Response> {
    constructor() {
        super("CChinaAgreementSessions_StartAgreementSessionInGame_Response", [
            { no: 1, name: "agreement_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CChinaAgreementSessions_StartAgreementSessionInGame_Response>): CChinaAgreementSessions_StartAgreementSessionInGame_Response {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CChinaAgreementSessions_StartAgreementSessionInGame_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CChinaAgreementSessions_StartAgreementSessionInGame_Response): CChinaAgreementSessions_StartAgreementSessionInGame_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string agreement_url */ 1:
                    message.agreementUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CChinaAgreementSessions_StartAgreementSessionInGame_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string agreement_url = 1; */
        if (message.agreementUrl !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.agreementUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CChinaAgreementSessions_StartAgreementSessionInGame_Response
 */
export const CChinaAgreementSessions_StartAgreementSessionInGame_Response = new CChinaAgreementSessions_StartAgreementSessionInGame_Response$Type();
