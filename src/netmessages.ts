// @generated by protobuf-ts 2.0.7 with parameter generate_dependencies
// @generated from protobuf file "netmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgVector
 */
export interface CMsgVector {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
}
/**
 * @generated from protobuf message CMsgVector2D
 */
export interface CMsgVector2D {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
}
/**
 * @generated from protobuf message CMsgQAngle
 */
export interface CMsgQAngle {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
}
/**
 * @generated from protobuf message CMsgRGBA
 */
export interface CMsgRGBA {
    /**
     * @generated from protobuf field: optional int32 r = 1;
     */
    r?: number;
    /**
     * @generated from protobuf field: optional int32 g = 2;
     */
    g?: number;
    /**
     * @generated from protobuf field: optional int32 b = 3;
     */
    b?: number;
    /**
     * @generated from protobuf field: optional int32 a = 4;
     */
    a?: number;
}
/**
 * @generated from protobuf message CNETMsg_Tick
 */
export interface CNETMsg_Tick {
    /**
     * @generated from protobuf field: optional uint32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional uint32 host_computationtime = 4;
     */
    hostComputationtime?: number;
    /**
     * @generated from protobuf field: optional uint32 host_computationtime_std_deviation = 5;
     */
    hostComputationtimeStdDeviation?: number;
    /**
     * @generated from protobuf field: optional uint32 host_framestarttime_std_deviation = 6;
     */
    hostFramestarttimeStdDeviation?: number;
    /**
     * @generated from protobuf field: optional uint32 hltv_replay_flags = 7;
     */
    hltvReplayFlags?: number;
}
/**
 * @generated from protobuf message CNETMsg_StringCmd
 */
export interface CNETMsg_StringCmd {
    /**
     * @generated from protobuf field: optional string command = 1;
     */
    command?: string;
}
/**
 * @generated from protobuf message CNETMsg_SignonState
 */
export interface CNETMsg_SignonState {
    /**
     * @generated from protobuf field: optional uint32 signon_state = 1;
     */
    signonState?: number;
    /**
     * @generated from protobuf field: optional uint32 spawn_count = 2;
     */
    spawnCount?: number;
    /**
     * @generated from protobuf field: optional uint32 num_server_players = 3;
     */
    numServerPlayers?: number;
    /**
     * @generated from protobuf field: repeated string players_networkids = 4;
     */
    playersNetworkids: string[];
    /**
     * @generated from protobuf field: optional string map_name = 5;
     */
    mapName?: string;
}
/**
 * @generated from protobuf message CMsg_CVars
 */
export interface CMsg_CVars {
    /**
     * @generated from protobuf field: repeated CMsg_CVars.CVar cvars = 1;
     */
    cvars: CMsg_CVars_CVar[];
}
/**
 * @generated from protobuf message CMsg_CVars.CVar
 */
export interface CMsg_CVars_CVar {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
    /**
     * @generated from protobuf field: optional uint32 dictionary_name = 3;
     */
    dictionaryName?: number;
}
/**
 * @generated from protobuf message CNETMsg_SetConVar
 */
export interface CNETMsg_SetConVar {
    /**
     * @generated from protobuf field: optional CMsg_CVars convars = 1;
     */
    convars?: CMsg_CVars;
}
/**
 * @generated from protobuf message CNETMsg_NOP
 */
export interface CNETMsg_NOP {
}
/**
 * @generated from protobuf message CNETMsg_Disconnect
 */
export interface CNETMsg_Disconnect {
    /**
     * @generated from protobuf field: optional string text = 1;
     */
    text?: string;
}
/**
 * @generated from protobuf message CNETMsg_File
 */
export interface CNETMsg_File {
    /**
     * @generated from protobuf field: optional int32 transfer_id = 1;
     */
    transferId?: number;
    /**
     * @generated from protobuf field: optional string file_name = 2;
     */
    fileName?: string;
    /**
     * @generated from protobuf field: optional bool is_replay_demo_file = 3;
     */
    isReplayDemoFile?: boolean;
    /**
     * @generated from protobuf field: optional bool deny = 4;
     */
    deny?: boolean;
}
/**
 * @generated from protobuf message CNETMsg_SplitScreenUser
 */
export interface CNETMsg_SplitScreenUser {
    /**
     * @generated from protobuf field: optional int32 slot = 1;
     */
    slot?: number;
}
/**
 * @generated from protobuf message CNETMsg_PlayerAvatarData
 */
export interface CNETMsg_PlayerAvatarData {
    /**
     * @generated from protobuf field: optional uint32 accountid = 1;
     */
    accountid?: number;
    /**
     * @generated from protobuf field: optional bytes rgb = 2;
     */
    rgb?: Uint8Array;
}
/**
 * @generated from protobuf message CCLCMsg_ClientInfo
 */
export interface CCLCMsg_ClientInfo {
    /**
     * @generated from protobuf field: optional fixed32 send_table_crc = 1;
     */
    sendTableCrc?: number;
    /**
     * @generated from protobuf field: optional uint32 server_count = 2;
     */
    serverCount?: number;
    /**
     * @generated from protobuf field: optional bool is_hltv = 3;
     */
    isHltv?: boolean;
    /**
     * @generated from protobuf field: optional bool is_replay = 4;
     */
    isReplay?: boolean;
    /**
     * @generated from protobuf field: optional uint32 friends_id = 5;
     */
    friendsId?: number;
    /**
     * @generated from protobuf field: optional string friends_name = 6;
     */
    friendsName?: string;
    /**
     * @generated from protobuf field: repeated fixed32 custom_files = 7;
     */
    customFiles: number[];
}
/**
 * @generated from protobuf message CCLCMsg_Move
 */
export interface CCLCMsg_Move {
    /**
     * @generated from protobuf field: optional uint32 num_backup_commands = 1;
     */
    numBackupCommands?: number;
    /**
     * @generated from protobuf field: optional uint32 num_new_commands = 2;
     */
    numNewCommands?: number;
    /**
     * @generated from protobuf field: optional bytes data = 3;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CCLCMsg_VoiceData
 */
export interface CCLCMsg_VoiceData {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 xuid = 2;
     */
    xuid?: bigint;
    /**
     * @generated from protobuf field: optional VoiceDataFormat_t format = 3;
     */
    format?: VoiceDataFormat_t;
    /**
     * @generated from protobuf field: optional int32 sequence_bytes = 4;
     */
    sequenceBytes?: number;
    /**
     * @generated from protobuf field: optional uint32 section_number = 5;
     */
    sectionNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 uncompressed_sample_offset = 6;
     */
    uncompressedSampleOffset?: number;
}
/**
 * @generated from protobuf message CCLCMsg_BaselineAck
 */
export interface CCLCMsg_BaselineAck {
    /**
     * @generated from protobuf field: optional int32 baseline_tick = 1;
     */
    baselineTick?: number;
    /**
     * @generated from protobuf field: optional int32 baseline_nr = 2;
     */
    baselineNr?: number;
}
/**
 * @generated from protobuf message CCLCMsg_ListenEvents
 */
export interface CCLCMsg_ListenEvents {
    /**
     * @generated from protobuf field: repeated fixed32 event_mask = 1;
     */
    eventMask: number[];
}
/**
 * @generated from protobuf message CCLCMsg_RespondCvarValue
 */
export interface CCLCMsg_RespondCvarValue {
    /**
     * @generated from protobuf field: optional int32 cookie = 1;
     */
    cookie?: number;
    /**
     * @generated from protobuf field: optional int32 status_code = 2;
     */
    statusCode?: number;
    /**
     * @generated from protobuf field: optional string name = 3;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 4;
     */
    value?: string;
}
/**
 * @generated from protobuf message CCLCMsg_FileCRCCheck
 */
export interface CCLCMsg_FileCRCCheck {
    /**
     * @generated from protobuf field: optional int32 code_path = 1;
     */
    codePath?: number;
    /**
     * @generated from protobuf field: optional string path = 2;
     */
    path?: string;
    /**
     * @generated from protobuf field: optional int32 code_filename = 3;
     */
    codeFilename?: number;
    /**
     * @generated from protobuf field: optional string filename = 4;
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional int32 file_fraction = 5;
     */
    fileFraction?: number;
    /**
     * @generated from protobuf field: optional bytes md5 = 6;
     */
    md5?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 crc = 7;
     */
    crc?: number;
    /**
     * @generated from protobuf field: optional int32 file_hash_type = 8;
     */
    fileHashType?: number;
    /**
     * @generated from protobuf field: optional int32 file_len = 9;
     */
    fileLen?: number;
    /**
     * @generated from protobuf field: optional int32 pack_file_id = 10;
     */
    packFileId?: number;
    /**
     * @generated from protobuf field: optional int32 pack_file_number = 11;
     */
    packFileNumber?: number;
}
/**
 * @generated from protobuf message CCLCMsg_LoadingProgress
 */
export interface CCLCMsg_LoadingProgress {
    /**
     * @generated from protobuf field: optional int32 progress = 1;
     */
    progress?: number;
}
/**
 * @generated from protobuf message CCLCMsg_SplitPlayerConnect
 */
export interface CCLCMsg_SplitPlayerConnect {
    /**
     * @generated from protobuf field: optional CMsg_CVars convars = 1;
     */
    convars?: CMsg_CVars;
}
/**
 * @generated from protobuf message CCLCMsg_CmdKeyValues
 */
export interface CCLCMsg_CmdKeyValues {
    /**
     * @generated from protobuf field: optional bytes keyvalues = 1;
     */
    keyvalues?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_ServerInfo
 */
export interface CSVCMsg_ServerInfo {
    /**
     * @generated from protobuf field: optional int32 protocol = 1;
     */
    protocol?: number;
    /**
     * @generated from protobuf field: optional int32 server_count = 2;
     */
    serverCount?: number;
    /**
     * @generated from protobuf field: optional bool is_dedicated = 3;
     */
    isDedicated?: boolean;
    /**
     * @generated from protobuf field: optional bool is_official_valve_server = 4;
     */
    isOfficialValveServer?: boolean;
    /**
     * @generated from protobuf field: optional bool is_hltv = 5;
     */
    isHltv?: boolean;
    /**
     * @generated from protobuf field: optional bool is_replay = 6;
     */
    isReplay?: boolean;
    /**
     * @generated from protobuf field: optional bool is_redirecting_to_proxy_relay = 21;
     */
    isRedirectingToProxyRelay?: boolean;
    /**
     * @generated from protobuf field: optional int32 c_os = 7;
     */
    cOs?: number;
    /**
     * @generated from protobuf field: optional fixed32 map_crc = 8;
     */
    mapCrc?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_crc = 9;
     */
    clientCrc?: number;
    /**
     * @generated from protobuf field: optional fixed32 string_table_crc = 10;
     */
    stringTableCrc?: number;
    /**
     * @generated from protobuf field: optional int32 max_clients = 11;
     */
    maxClients?: number;
    /**
     * @generated from protobuf field: optional int32 max_classes = 12;
     */
    maxClasses?: number;
    /**
     * @generated from protobuf field: optional int32 player_slot = 13;
     */
    playerSlot?: number;
    /**
     * @generated from protobuf field: optional float tick_interval = 14;
     */
    tickInterval?: number;
    /**
     * @generated from protobuf field: optional string game_dir = 15;
     */
    gameDir?: string;
    /**
     * @generated from protobuf field: optional string map_name = 16;
     */
    mapName?: string;
    /**
     * @generated from protobuf field: optional string map_group_name = 17;
     */
    mapGroupName?: string;
    /**
     * @generated from protobuf field: optional string sky_name = 18;
     */
    skyName?: string;
    /**
     * @generated from protobuf field: optional string host_name = 19;
     */
    hostName?: string;
    /**
     * @generated from protobuf field: optional uint32 public_ip = 20;
     */
    publicIp?: number;
    /**
     * @generated from protobuf field: optional uint64 ugc_map_id = 22;
     */
    ugcMapId?: bigint;
}
/**
 * @generated from protobuf message CSVCMsg_ClassInfo
 */
export interface CSVCMsg_ClassInfo {
    /**
     * @generated from protobuf field: optional bool create_on_client = 1;
     */
    createOnClient?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_ClassInfo.class_t classes = 2;
     */
    classes: CSVCMsg_ClassInfo_class_t[];
}
/**
 * @generated from protobuf message CSVCMsg_ClassInfo.class_t
 */
export interface CSVCMsg_ClassInfo_class_t {
    /**
     * @generated from protobuf field: optional int32 class_id = 1;
     */
    classId?: number;
    /**
     * @generated from protobuf field: optional string data_table_name = 2;
     */
    dataTableName?: string;
    /**
     * @generated from protobuf field: optional string class_name = 3;
     */
    className?: string;
}
/**
 * @generated from protobuf message CSVCMsg_SendTable
 */
export interface CSVCMsg_SendTable {
    /**
     * @generated from protobuf field: optional bool is_end = 1;
     */
    isEnd?: boolean;
    /**
     * @generated from protobuf field: optional string net_table_name = 2;
     */
    netTableName?: string;
    /**
     * @generated from protobuf field: optional bool needs_decoder = 3;
     */
    needsDecoder?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_SendTable.sendprop_t props = 4;
     */
    props: CSVCMsg_SendTable_sendprop_t[];
}
/**
 * @generated from protobuf message CSVCMsg_SendTable.sendprop_t
 */
export interface CSVCMsg_SendTable_sendprop_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string var_name = 2;
     */
    varName?: string;
    /**
     * @generated from protobuf field: optional int32 flags = 3;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional int32 priority = 4;
     */
    priority?: number;
    /**
     * @generated from protobuf field: optional string dt_name = 5;
     */
    dtName?: string;
    /**
     * @generated from protobuf field: optional int32 num_elements = 6;
     */
    numElements?: number;
    /**
     * @generated from protobuf field: optional float low_value = 7;
     */
    lowValue?: number;
    /**
     * @generated from protobuf field: optional float high_value = 8;
     */
    highValue?: number;
    /**
     * @generated from protobuf field: optional int32 num_bits = 9;
     */
    numBits?: number;
}
/**
 * @generated from protobuf message CSVCMsg_Print
 */
export interface CSVCMsg_Print {
    /**
     * @generated from protobuf field: optional string text = 1;
     */
    text?: string;
}
/**
 * @generated from protobuf message CSVCMsg_SetPause
 */
export interface CSVCMsg_SetPause {
    /**
     * @generated from protobuf field: optional bool paused = 1;
     */
    paused?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_SetView
 */
export interface CSVCMsg_SetView {
    /**
     * @generated from protobuf field: optional int32 entity_index = 1;
     */
    entityIndex?: number;
}
/**
 * @generated from protobuf message CSVCMsg_CreateStringTable
 */
export interface CSVCMsg_CreateStringTable {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 max_entries = 2;
     */
    maxEntries?: number;
    /**
     * @generated from protobuf field: optional int32 num_entries = 3;
     */
    numEntries?: number;
    /**
     * @generated from protobuf field: optional bool user_data_fixed_size = 4;
     */
    userDataFixedSize?: boolean;
    /**
     * @generated from protobuf field: optional int32 user_data_size = 5;
     */
    userDataSize?: number;
    /**
     * @generated from protobuf field: optional int32 user_data_size_bits = 6;
     */
    userDataSizeBits?: number;
    /**
     * @generated from protobuf field: optional int32 flags = 7;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional bytes string_data = 8;
     */
    stringData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_UpdateStringTable
 */
export interface CSVCMsg_UpdateStringTable {
    /**
     * @generated from protobuf field: optional int32 table_id = 1;
     */
    tableId?: number;
    /**
     * @generated from protobuf field: optional int32 num_changed_entries = 2;
     */
    numChangedEntries?: number;
    /**
     * @generated from protobuf field: optional bytes string_data = 3;
     */
    stringData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_VoiceInit
 */
export interface CSVCMsg_VoiceInit {
    /**
     * @generated from protobuf field: optional int32 quality = 1;
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional string codec = 2;
     */
    codec?: string;
    /**
     * @generated from protobuf field: optional int32 version = 3;
     */
    version?: number;
}
/**
 * @generated from protobuf message CSVCMsg_VoiceData
 */
export interface CSVCMsg_VoiceData {
    /**
     * @generated from protobuf field: optional int32 client = 1;
     */
    client?: number;
    /**
     * @generated from protobuf field: optional bool proximity = 2;
     */
    proximity?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 xuid = 3;
     */
    xuid?: bigint;
    /**
     * @generated from protobuf field: optional int32 audible_mask = 4;
     */
    audibleMask?: number;
    /**
     * @generated from protobuf field: optional bytes voice_data = 5;
     */
    voiceData?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool caster = 6;
     */
    caster?: boolean;
    /**
     * @generated from protobuf field: optional VoiceDataFormat_t format = 7;
     */
    format?: VoiceDataFormat_t;
    /**
     * @generated from protobuf field: optional int32 sequence_bytes = 8;
     */
    sequenceBytes?: number;
    /**
     * @generated from protobuf field: optional uint32 section_number = 9;
     */
    sectionNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 uncompressed_sample_offset = 10;
     */
    uncompressedSampleOffset?: number;
}
/**
 * @generated from protobuf message CSVCMsg_FixAngle
 */
export interface CSVCMsg_FixAngle {
    /**
     * @generated from protobuf field: optional bool relative = 1;
     */
    relative?: boolean;
    /**
     * @generated from protobuf field: optional CMsgQAngle angle = 2;
     */
    angle?: CMsgQAngle;
}
/**
 * @generated from protobuf message CSVCMsg_CrosshairAngle
 */
export interface CSVCMsg_CrosshairAngle {
    /**
     * @generated from protobuf field: optional CMsgQAngle angle = 1;
     */
    angle?: CMsgQAngle;
}
/**
 * @generated from protobuf message CSVCMsg_Prefetch
 */
export interface CSVCMsg_Prefetch {
    /**
     * @generated from protobuf field: optional int32 sound_index = 1;
     */
    soundIndex?: number;
}
/**
 * @generated from protobuf message CSVCMsg_BSPDecal
 */
export interface CSVCMsg_BSPDecal {
    /**
     * @generated from protobuf field: optional CMsgVector pos = 1;
     */
    pos?: CMsgVector;
    /**
     * @generated from protobuf field: optional int32 decal_texture_index = 2;
     */
    decalTextureIndex?: number;
    /**
     * @generated from protobuf field: optional int32 entity_index = 3;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 model_index = 4;
     */
    modelIndex?: number;
    /**
     * @generated from protobuf field: optional bool low_priority = 5;
     */
    lowPriority?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_SplitScreen
 */
export interface CSVCMsg_SplitScreen {
    /**
     * @generated from protobuf field: optional ESplitScreenMessageType type = 1;
     */
    type?: ESplitScreenMessageType;
    /**
     * @generated from protobuf field: optional int32 slot = 2;
     */
    slot?: number;
    /**
     * @generated from protobuf field: optional int32 player_index = 3;
     */
    playerIndex?: number;
}
/**
 * @generated from protobuf message CSVCMsg_GetCvarValue
 */
export interface CSVCMsg_GetCvarValue {
    /**
     * @generated from protobuf field: optional int32 cookie = 1;
     */
    cookie?: number;
    /**
     * @generated from protobuf field: optional string cvar_name = 2;
     */
    cvarName?: string;
}
/**
 * @generated from protobuf message CSVCMsg_Menu
 */
export interface CSVCMsg_Menu {
    /**
     * @generated from protobuf field: optional int32 dialog_type = 1;
     */
    dialogType?: number;
    /**
     * @generated from protobuf field: optional bytes menu_key_values = 2;
     */
    menuKeyValues?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_UserMessage
 */
export interface CSVCMsg_UserMessage {
    /**
     * @generated from protobuf field: optional int32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional bytes msg_data = 2;
     */
    msgData?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 passthrough = 3;
     */
    passthrough?: number;
}
/**
 * @generated from protobuf message CSVCMsg_PaintmapData
 */
export interface CSVCMsg_PaintmapData {
    /**
     * @generated from protobuf field: optional bytes paintmap = 1;
     */
    paintmap?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_GameEvent
 */
export interface CSVCMsg_GameEvent {
    /**
     * @generated from protobuf field: optional string event_name = 1;
     */
    eventName?: string;
    /**
     * @generated from protobuf field: optional int32 eventid = 2;
     */
    eventid?: number;
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEvent.key_t keys = 3;
     */
    keys: CSVCMsg_GameEvent_key_t[];
    /**
     * @generated from protobuf field: optional int32 passthrough = 4;
     */
    passthrough?: number;
}
/**
 * @generated from protobuf message CSVCMsg_GameEvent.key_t
 */
export interface CSVCMsg_GameEvent_key_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string val_string = 2;
     */
    valString?: string;
    /**
     * @generated from protobuf field: optional float val_float = 3;
     */
    valFloat?: number;
    /**
     * @generated from protobuf field: optional int32 val_long = 4;
     */
    valLong?: number;
    /**
     * @generated from protobuf field: optional int32 val_short = 5;
     */
    valShort?: number;
    /**
     * @generated from protobuf field: optional int32 val_byte = 6;
     */
    valByte?: number;
    /**
     * @generated from protobuf field: optional bool val_bool = 7;
     */
    valBool?: boolean;
    /**
     * @generated from protobuf field: optional uint64 val_uint64 = 8;
     */
    valUint64?: bigint;
    /**
     * @generated from protobuf field: optional bytes val_wstring = 9;
     */
    valWstring?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList
 */
export interface CSVCMsg_GameEventList {
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEventList.descriptor_t descriptors = 1;
     */
    descriptors: CSVCMsg_GameEventList_descriptor_t[];
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList.key_t
 */
export interface CSVCMsg_GameEventList_key_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList.descriptor_t
 */
export interface CSVCMsg_GameEventList_descriptor_t {
    /**
     * @generated from protobuf field: optional int32 eventid = 1;
     */
    eventid?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEventList.key_t keys = 3;
     */
    keys: CSVCMsg_GameEventList_key_t[];
}
/**
 * @generated from protobuf message CSVCMsg_TempEntities
 */
export interface CSVCMsg_TempEntities {
    /**
     * @generated from protobuf field: optional bool reliable = 1;
     */
    reliable?: boolean;
    /**
     * @generated from protobuf field: optional int32 num_entries = 2;
     */
    numEntries?: number;
    /**
     * @generated from protobuf field: optional bytes entity_data = 3;
     */
    entityData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_PacketEntities
 */
export interface CSVCMsg_PacketEntities {
    /**
     * @generated from protobuf field: optional int32 max_entries = 1;
     */
    maxEntries?: number;
    /**
     * @generated from protobuf field: optional int32 updated_entries = 2;
     */
    updatedEntries?: number;
    /**
     * @generated from protobuf field: optional bool is_delta = 3;
     */
    isDelta?: boolean;
    /**
     * @generated from protobuf field: optional bool update_baseline = 4;
     */
    updateBaseline?: boolean;
    /**
     * @generated from protobuf field: optional int32 baseline = 5;
     */
    baseline?: number;
    /**
     * @generated from protobuf field: optional int32 delta_from = 6;
     */
    deltaFrom?: number;
    /**
     * @generated from protobuf field: optional bytes entity_data = 7;
     */
    entityData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_Sounds
 */
export interface CSVCMsg_Sounds {
    /**
     * @generated from protobuf field: optional bool reliable_sound = 1;
     */
    reliableSound?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_Sounds.sounddata_t sounds = 2;
     */
    sounds: CSVCMsg_Sounds_sounddata_t[];
}
/**
 * @generated from protobuf message CSVCMsg_Sounds.sounddata_t
 */
export interface CSVCMsg_Sounds_sounddata_t {
    /**
     * @generated from protobuf field: optional sint32 origin_x = 1;
     */
    originX?: number;
    /**
     * @generated from protobuf field: optional sint32 origin_y = 2;
     */
    originY?: number;
    /**
     * @generated from protobuf field: optional sint32 origin_z = 3;
     */
    originZ?: number;
    /**
     * @generated from protobuf field: optional uint32 volume = 4;
     */
    volume?: number;
    /**
     * @generated from protobuf field: optional float delay_value = 5;
     */
    delayValue?: number;
    /**
     * @generated from protobuf field: optional int32 sequence_number = 6;
     */
    sequenceNumber?: number;
    /**
     * @generated from protobuf field: optional int32 entity_index = 7;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 channel = 8;
     */
    channel?: number;
    /**
     * @generated from protobuf field: optional int32 pitch = 9;
     */
    pitch?: number;
    /**
     * @generated from protobuf field: optional int32 flags = 10;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 sound_num = 11;
     */
    soundNum?: number;
    /**
     * @generated from protobuf field: optional fixed32 sound_num_handle = 12;
     */
    soundNumHandle?: number;
    /**
     * @generated from protobuf field: optional int32 speaker_entity = 13;
     */
    speakerEntity?: number;
    /**
     * @generated from protobuf field: optional int32 random_seed = 14;
     */
    randomSeed?: number;
    /**
     * @generated from protobuf field: optional int32 sound_level = 15;
     */
    soundLevel?: number;
    /**
     * @generated from protobuf field: optional bool is_sentence = 16;
     */
    isSentence?: boolean;
    /**
     * @generated from protobuf field: optional bool is_ambient = 17;
     */
    isAmbient?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_EntityMsg
 */
export interface CSVCMsg_EntityMsg {
    /**
     * @generated from protobuf field: optional int32 ent_index = 1;
     */
    entIndex?: number;
    /**
     * @generated from protobuf field: optional int32 class_id = 2;
     */
    classId?: number;
    /**
     * @generated from protobuf field: optional bytes ent_data = 3;
     */
    entData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_CmdKeyValues
 */
export interface CSVCMsg_CmdKeyValues {
    /**
     * @generated from protobuf field: optional bytes keyvalues = 1;
     */
    keyvalues?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_EncryptedData
 */
export interface CSVCMsg_EncryptedData {
    /**
     * @generated from protobuf field: optional bytes encrypted = 1;
     */
    encrypted?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 key_type = 2;
     */
    keyType?: number;
}
/**
 * @generated from protobuf message CSVCMsg_HltvReplay
 */
export interface CSVCMsg_HltvReplay {
    /**
     * @generated from protobuf field: optional int32 delay = 1;
     */
    delay?: number;
    /**
     * @generated from protobuf field: optional int32 primary_target = 2;
     */
    primaryTarget?: number;
    /**
     * @generated from protobuf field: optional int32 replay_stop_at = 3;
     */
    replayStopAt?: number;
    /**
     * @generated from protobuf field: optional int32 replay_start_at = 4;
     */
    replayStartAt?: number;
    /**
     * @generated from protobuf field: optional int32 replay_slowdown_begin = 5;
     */
    replaySlowdownBegin?: number;
    /**
     * @generated from protobuf field: optional int32 replay_slowdown_end = 6;
     */
    replaySlowdownEnd?: number;
    /**
     * @generated from protobuf field: optional float replay_slowdown_rate = 7;
     */
    replaySlowdownRate?: number;
}
/**
 * @generated from protobuf message CCLCMsg_HltvReplay
 */
export interface CCLCMsg_HltvReplay {
    /**
     * @generated from protobuf field: optional int32 request = 1;
     */
    request?: number;
    /**
     * @generated from protobuf field: optional float slowdown_length = 2;
     */
    slowdownLength?: number;
    /**
     * @generated from protobuf field: optional float slowdown_rate = 3;
     */
    slowdownRate?: number;
    /**
     * @generated from protobuf field: optional int32 primary_target_ent_index = 4;
     */
    primaryTargetEntIndex?: number;
    /**
     * @generated from protobuf field: optional float event_time = 5;
     */
    eventTime?: number;
}
/**
 * @generated from protobuf message CSVCMsg_Broadcast_Command
 */
export interface CSVCMsg_Broadcast_Command {
    /**
     * @generated from protobuf field: optional string cmd = 1;
     */
    cmd?: string;
}
/**
 * @generated from protobuf enum NET_Messages
 */
export enum NET_Messages {
    /**
     * @generated from protobuf enum value: net_NOP = 0;
     */
    net_NOP = 0,
    /**
     * @generated from protobuf enum value: net_Disconnect = 1;
     */
    net_Disconnect = 1,
    /**
     * @generated from protobuf enum value: net_File = 2;
     */
    net_File = 2,
    /**
     * @generated from protobuf enum value: net_SplitScreenUser = 3;
     */
    net_SplitScreenUser = 3,
    /**
     * @generated from protobuf enum value: net_Tick = 4;
     */
    net_Tick = 4,
    /**
     * @generated from protobuf enum value: net_StringCmd = 5;
     */
    net_StringCmd = 5,
    /**
     * @generated from protobuf enum value: net_SetConVar = 6;
     */
    net_SetConVar = 6,
    /**
     * @generated from protobuf enum value: net_SignonState = 7;
     */
    net_SignonState = 7,
    /**
     * @generated from protobuf enum value: net_PlayerAvatarData = 100;
     */
    net_PlayerAvatarData = 100
}
/**
 * @generated from protobuf enum CLC_Messages
 */
export enum CLC_Messages {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: clc_ClientInfo = 8;
     */
    clc_ClientInfo = 8,
    /**
     * @generated from protobuf enum value: clc_Move = 9;
     */
    clc_Move = 9,
    /**
     * @generated from protobuf enum value: clc_VoiceData = 10;
     */
    clc_VoiceData = 10,
    /**
     * @generated from protobuf enum value: clc_BaselineAck = 11;
     */
    clc_BaselineAck = 11,
    /**
     * @generated from protobuf enum value: clc_ListenEvents = 12;
     */
    clc_ListenEvents = 12,
    /**
     * @generated from protobuf enum value: clc_RespondCvarValue = 13;
     */
    clc_RespondCvarValue = 13,
    /**
     * @generated from protobuf enum value: clc_FileCRCCheck = 14;
     */
    clc_FileCRCCheck = 14,
    /**
     * @generated from protobuf enum value: clc_LoadingProgress = 15;
     */
    clc_LoadingProgress = 15,
    /**
     * @generated from protobuf enum value: clc_SplitPlayerConnect = 16;
     */
    clc_SplitPlayerConnect = 16,
    /**
     * @generated from protobuf enum value: clc_ClientMessage = 17;
     */
    clc_ClientMessage = 17,
    /**
     * @generated from protobuf enum value: clc_CmdKeyValues = 18;
     */
    clc_CmdKeyValues = 18,
    /**
     * @generated from protobuf enum value: clc_HltvReplay = 20;
     */
    clc_HltvReplay = 20
}
/**
 * @generated from protobuf enum VoiceDataFormat_t
 */
export enum VoiceDataFormat_t {
    /**
     * @generated from protobuf enum value: VOICEDATA_FORMAT_STEAM = 0;
     */
    VOICEDATA_FORMAT_STEAM = 0,
    /**
     * @generated from protobuf enum value: VOICEDATA_FORMAT_ENGINE = 1;
     */
    VOICEDATA_FORMAT_ENGINE = 1
}
/**
 * @generated from protobuf enum ESplitScreenMessageType
 */
export enum ESplitScreenMessageType {
    /**
     * @generated from protobuf enum value: MSG_SPLITSCREEN_ADDUSER = 0;
     */
    MSG_SPLITSCREEN_ADDUSER = 0,
    /**
     * @generated from protobuf enum value: MSG_SPLITSCREEN_REMOVEUSER = 1;
     */
    MSG_SPLITSCREEN_REMOVEUSER = 1,
    /**
     * @generated from protobuf enum value: MSG_SPLITSCREEN_REMOVEUSER = 1;
     */
    MSG_SPLITSCREEN_TYPE_BITS = 1
}
/**
 * @generated from protobuf enum SVC_Messages
 */
export enum SVC_Messages {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: svc_ServerInfo = 8;
     */
    svc_ServerInfo = 8,
    /**
     * @generated from protobuf enum value: svc_SendTable = 9;
     */
    svc_SendTable = 9,
    /**
     * @generated from protobuf enum value: svc_ClassInfo = 10;
     */
    svc_ClassInfo = 10,
    /**
     * @generated from protobuf enum value: svc_SetPause = 11;
     */
    svc_SetPause = 11,
    /**
     * @generated from protobuf enum value: svc_CreateStringTable = 12;
     */
    svc_CreateStringTable = 12,
    /**
     * @generated from protobuf enum value: svc_UpdateStringTable = 13;
     */
    svc_UpdateStringTable = 13,
    /**
     * @generated from protobuf enum value: svc_VoiceInit = 14;
     */
    svc_VoiceInit = 14,
    /**
     * @generated from protobuf enum value: svc_VoiceData = 15;
     */
    svc_VoiceData = 15,
    /**
     * @generated from protobuf enum value: svc_Print = 16;
     */
    svc_Print = 16,
    /**
     * @generated from protobuf enum value: svc_Sounds = 17;
     */
    svc_Sounds = 17,
    /**
     * @generated from protobuf enum value: svc_SetView = 18;
     */
    svc_SetView = 18,
    /**
     * @generated from protobuf enum value: svc_FixAngle = 19;
     */
    svc_FixAngle = 19,
    /**
     * @generated from protobuf enum value: svc_CrosshairAngle = 20;
     */
    svc_CrosshairAngle = 20,
    /**
     * @generated from protobuf enum value: svc_BSPDecal = 21;
     */
    svc_BSPDecal = 21,
    /**
     * @generated from protobuf enum value: svc_SplitScreen = 22;
     */
    svc_SplitScreen = 22,
    /**
     * @generated from protobuf enum value: svc_UserMessage = 23;
     */
    svc_UserMessage = 23,
    /**
     * @generated from protobuf enum value: svc_EntityMessage = 24;
     */
    svc_EntityMessage = 24,
    /**
     * @generated from protobuf enum value: svc_GameEvent = 25;
     */
    svc_GameEvent = 25,
    /**
     * @generated from protobuf enum value: svc_PacketEntities = 26;
     */
    svc_PacketEntities = 26,
    /**
     * @generated from protobuf enum value: svc_TempEntities = 27;
     */
    svc_TempEntities = 27,
    /**
     * @generated from protobuf enum value: svc_Prefetch = 28;
     */
    svc_Prefetch = 28,
    /**
     * @generated from protobuf enum value: svc_Menu = 29;
     */
    svc_Menu = 29,
    /**
     * @generated from protobuf enum value: svc_GameEventList = 30;
     */
    svc_GameEventList = 30,
    /**
     * @generated from protobuf enum value: svc_GetCvarValue = 31;
     */
    svc_GetCvarValue = 31,
    /**
     * @generated from protobuf enum value: svc_PaintmapData = 33;
     */
    svc_PaintmapData = 33,
    /**
     * @generated from protobuf enum value: svc_CmdKeyValues = 34;
     */
    svc_CmdKeyValues = 34,
    /**
     * @generated from protobuf enum value: svc_EncryptedData = 35;
     */
    svc_EncryptedData = 35,
    /**
     * @generated from protobuf enum value: svc_HltvReplay = 36;
     */
    svc_HltvReplay = 36,
    /**
     * @generated from protobuf enum value: svc_Broadcast_Command = 38;
     */
    svc_Broadcast_Command = 38
}
/**
 * @generated from protobuf enum ReplayEventType_t
 */
export enum ReplayEventType_t {
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_CANCEL = 0;
     */
    REPLAY_EVENT_CANCEL = 0,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_DEATH = 1;
     */
    REPLAY_EVENT_DEATH = 1,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_GENERIC = 2;
     */
    REPLAY_EVENT_GENERIC = 2,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3;
     */
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgVector$Type extends MessageType<CMsgVector> {
    constructor() {
        super("CMsgVector", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgVector>): CMsgVector {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgVector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgVector): CMsgVector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgVector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgVector
 */
export const CMsgVector = new CMsgVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgVector2D$Type extends MessageType<CMsgVector2D> {
    constructor() {
        super("CMsgVector2D", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgVector2D>): CMsgVector2D {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgVector2D>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgVector2D): CMsgVector2D {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgVector2D, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgVector2D
 */
export const CMsgVector2D = new CMsgVector2D$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgQAngle$Type extends MessageType<CMsgQAngle> {
    constructor() {
        super("CMsgQAngle", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgQAngle>): CMsgQAngle {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgQAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgQAngle): CMsgQAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgQAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgQAngle
 */
export const CMsgQAngle = new CMsgQAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgRGBA$Type extends MessageType<CMsgRGBA> {
    constructor() {
        super("CMsgRGBA", [
            { no: 1, name: "r", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "g", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "b", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgRGBA>): CMsgRGBA {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsgRGBA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgRGBA): CMsgRGBA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 r */ 1:
                    message.r = reader.int32();
                    break;
                case /* optional int32 g */ 2:
                    message.g = reader.int32();
                    break;
                case /* optional int32 b */ 3:
                    message.b = reader.int32();
                    break;
                case /* optional int32 a */ 4:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgRGBA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 r = 1; */
        if (message.r !== undefined)
            writer.tag(1, WireType.Varint).int32(message.r);
        /* optional int32 g = 2; */
        if (message.g !== undefined)
            writer.tag(2, WireType.Varint).int32(message.g);
        /* optional int32 b = 3; */
        if (message.b !== undefined)
            writer.tag(3, WireType.Varint).int32(message.b);
        /* optional int32 a = 4; */
        if (message.a !== undefined)
            writer.tag(4, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgRGBA
 */
export const CMsgRGBA = new CMsgRGBA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_Tick$Type extends MessageType<CNETMsg_Tick> {
    constructor() {
        super("CNETMsg_Tick", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "host_computationtime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "host_computationtime_std_deviation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "host_framestarttime_std_deviation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "hltv_replay_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_Tick>): CNETMsg_Tick {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_Tick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_Tick): CNETMsg_Tick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tick */ 1:
                    message.tick = reader.uint32();
                    break;
                case /* optional uint32 host_computationtime */ 4:
                    message.hostComputationtime = reader.uint32();
                    break;
                case /* optional uint32 host_computationtime_std_deviation */ 5:
                    message.hostComputationtimeStdDeviation = reader.uint32();
                    break;
                case /* optional uint32 host_framestarttime_std_deviation */ 6:
                    message.hostFramestarttimeStdDeviation = reader.uint32();
                    break;
                case /* optional uint32 hltv_replay_flags */ 7:
                    message.hltvReplayFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_Tick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tick);
        /* optional uint32 host_computationtime = 4; */
        if (message.hostComputationtime !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.hostComputationtime);
        /* optional uint32 host_computationtime_std_deviation = 5; */
        if (message.hostComputationtimeStdDeviation !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.hostComputationtimeStdDeviation);
        /* optional uint32 host_framestarttime_std_deviation = 6; */
        if (message.hostFramestarttimeStdDeviation !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.hostFramestarttimeStdDeviation);
        /* optional uint32 hltv_replay_flags = 7; */
        if (message.hltvReplayFlags !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.hltvReplayFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_Tick
 */
export const CNETMsg_Tick = new CNETMsg_Tick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_StringCmd$Type extends MessageType<CNETMsg_StringCmd> {
    constructor() {
        super("CNETMsg_StringCmd", [
            { no: 1, name: "command", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_StringCmd>): CNETMsg_StringCmd {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_StringCmd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_StringCmd): CNETMsg_StringCmd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string command */ 1:
                    message.command = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_StringCmd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string command = 1; */
        if (message.command !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_StringCmd
 */
export const CNETMsg_StringCmd = new CNETMsg_StringCmd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SignonState$Type extends MessageType<CNETMsg_SignonState> {
    constructor() {
        super("CNETMsg_SignonState", [
            { no: 1, name: "signon_state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "spawn_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_server_players", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "players_networkids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "map_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SignonState>): CNETMsg_SignonState {
        const message = { playersNetworkids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SignonState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SignonState): CNETMsg_SignonState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 signon_state */ 1:
                    message.signonState = reader.uint32();
                    break;
                case /* optional uint32 spawn_count */ 2:
                    message.spawnCount = reader.uint32();
                    break;
                case /* optional uint32 num_server_players */ 3:
                    message.numServerPlayers = reader.uint32();
                    break;
                case /* repeated string players_networkids */ 4:
                    message.playersNetworkids.push(reader.string());
                    break;
                case /* optional string map_name */ 5:
                    message.mapName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SignonState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 signon_state = 1; */
        if (message.signonState !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.signonState);
        /* optional uint32 spawn_count = 2; */
        if (message.spawnCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.spawnCount);
        /* optional uint32 num_server_players = 3; */
        if (message.numServerPlayers !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.numServerPlayers);
        /* repeated string players_networkids = 4; */
        for (let i = 0; i < message.playersNetworkids.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.playersNetworkids[i]);
        /* optional string map_name = 5; */
        if (message.mapName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.mapName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SignonState
 */
export const CNETMsg_SignonState = new CNETMsg_SignonState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsg_CVars$Type extends MessageType<CMsg_CVars> {
    constructor() {
        super("CMsg_CVars", [
            { no: 1, name: "cvars", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsg_CVars_CVar }
        ]);
    }
    create(value?: PartialMessage<CMsg_CVars>): CMsg_CVars {
        const message = { cvars: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsg_CVars>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsg_CVars): CMsg_CVars {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsg_CVars.CVar cvars */ 1:
                    message.cvars.push(CMsg_CVars_CVar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsg_CVars, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsg_CVars.CVar cvars = 1; */
        for (let i = 0; i < message.cvars.length; i++)
            CMsg_CVars_CVar.internalBinaryWrite(message.cvars[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsg_CVars
 */
export const CMsg_CVars = new CMsg_CVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsg_CVars_CVar$Type extends MessageType<CMsg_CVars_CVar> {
    constructor() {
        super("CMsg_CVars.CVar", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dictionary_name", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsg_CVars_CVar>): CMsg_CVars_CVar {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CMsg_CVars_CVar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsg_CVars_CVar): CMsg_CVars_CVar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                case /* optional uint32 dictionary_name */ 3:
                    message.dictionaryName = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsg_CVars_CVar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* optional uint32 dictionary_name = 3; */
        if (message.dictionaryName !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.dictionaryName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsg_CVars.CVar
 */
export const CMsg_CVars_CVar = new CMsg_CVars_CVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SetConVar$Type extends MessageType<CNETMsg_SetConVar> {
    constructor() {
        super("CNETMsg_SetConVar", [
            { no: 1, name: "convars", kind: "message", T: () => CMsg_CVars }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SetConVar>): CNETMsg_SetConVar {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SetConVar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SetConVar): CNETMsg_SetConVar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsg_CVars convars */ 1:
                    message.convars = CMsg_CVars.internalBinaryRead(reader, reader.uint32(), options, message.convars);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SetConVar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsg_CVars convars = 1; */
        if (message.convars)
            CMsg_CVars.internalBinaryWrite(message.convars, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SetConVar
 */
export const CNETMsg_SetConVar = new CNETMsg_SetConVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_NOP$Type extends MessageType<CNETMsg_NOP> {
    constructor() {
        super("CNETMsg_NOP", []);
    }
    create(value?: PartialMessage<CNETMsg_NOP>): CNETMsg_NOP {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_NOP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_NOP): CNETMsg_NOP {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CNETMsg_NOP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_NOP
 */
export const CNETMsg_NOP = new CNETMsg_NOP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_Disconnect$Type extends MessageType<CNETMsg_Disconnect> {
    constructor() {
        super("CNETMsg_Disconnect", [
            { no: 1, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_Disconnect>): CNETMsg_Disconnect {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_Disconnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_Disconnect): CNETMsg_Disconnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_Disconnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string text = 1; */
        if (message.text !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_Disconnect
 */
export const CNETMsg_Disconnect = new CNETMsg_Disconnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_File$Type extends MessageType<CNETMsg_File> {
    constructor() {
        super("CNETMsg_File", [
            { no: 1, name: "transfer_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_replay_demo_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "deny", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_File>): CNETMsg_File {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_File): CNETMsg_File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 transfer_id */ 1:
                    message.transferId = reader.int32();
                    break;
                case /* optional string file_name */ 2:
                    message.fileName = reader.string();
                    break;
                case /* optional bool is_replay_demo_file */ 3:
                    message.isReplayDemoFile = reader.bool();
                    break;
                case /* optional bool deny */ 4:
                    message.deny = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 transfer_id = 1; */
        if (message.transferId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.transferId);
        /* optional string file_name = 2; */
        if (message.fileName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* optional bool is_replay_demo_file = 3; */
        if (message.isReplayDemoFile !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isReplayDemoFile);
        /* optional bool deny = 4; */
        if (message.deny !== undefined)
            writer.tag(4, WireType.Varint).bool(message.deny);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_File
 */
export const CNETMsg_File = new CNETMsg_File$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SplitScreenUser$Type extends MessageType<CNETMsg_SplitScreenUser> {
    constructor() {
        super("CNETMsg_SplitScreenUser", [
            { no: 1, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SplitScreenUser>): CNETMsg_SplitScreenUser {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SplitScreenUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SplitScreenUser): CNETMsg_SplitScreenUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SplitScreenUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 slot = 1; */
        if (message.slot !== undefined)
            writer.tag(1, WireType.Varint).int32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SplitScreenUser
 */
export const CNETMsg_SplitScreenUser = new CNETMsg_SplitScreenUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_PlayerAvatarData$Type extends MessageType<CNETMsg_PlayerAvatarData> {
    constructor() {
        super("CNETMsg_PlayerAvatarData", [
            { no: 1, name: "accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rgb", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_PlayerAvatarData>): CNETMsg_PlayerAvatarData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_PlayerAvatarData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_PlayerAvatarData): CNETMsg_PlayerAvatarData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 accountid */ 1:
                    message.accountid = reader.uint32();
                    break;
                case /* optional bytes rgb */ 2:
                    message.rgb = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_PlayerAvatarData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 accountid = 1; */
        if (message.accountid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountid);
        /* optional bytes rgb = 2; */
        if (message.rgb !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.rgb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_PlayerAvatarData
 */
export const CNETMsg_PlayerAvatarData = new CNETMsg_PlayerAvatarData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_ClientInfo$Type extends MessageType<CCLCMsg_ClientInfo> {
    constructor() {
        super("CCLCMsg_ClientInfo", [
            { no: 1, name: "send_table_crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "server_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_hltv", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_replay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "friends_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "friends_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "custom_files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_ClientInfo>): CCLCMsg_ClientInfo {
        const message = { customFiles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_ClientInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_ClientInfo): CCLCMsg_ClientInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 send_table_crc */ 1:
                    message.sendTableCrc = reader.fixed32();
                    break;
                case /* optional uint32 server_count */ 2:
                    message.serverCount = reader.uint32();
                    break;
                case /* optional bool is_hltv */ 3:
                    message.isHltv = reader.bool();
                    break;
                case /* optional bool is_replay */ 4:
                    message.isReplay = reader.bool();
                    break;
                case /* optional uint32 friends_id */ 5:
                    message.friendsId = reader.uint32();
                    break;
                case /* optional string friends_name */ 6:
                    message.friendsName = reader.string();
                    break;
                case /* repeated fixed32 custom_files */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.customFiles.push(reader.fixed32());
                    else
                        message.customFiles.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_ClientInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 send_table_crc = 1; */
        if (message.sendTableCrc !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.sendTableCrc);
        /* optional uint32 server_count = 2; */
        if (message.serverCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.serverCount);
        /* optional bool is_hltv = 3; */
        if (message.isHltv !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isHltv);
        /* optional bool is_replay = 4; */
        if (message.isReplay !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isReplay);
        /* optional uint32 friends_id = 5; */
        if (message.friendsId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.friendsId);
        /* optional string friends_name = 6; */
        if (message.friendsName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.friendsName);
        /* repeated fixed32 custom_files = 7; */
        for (let i = 0; i < message.customFiles.length; i++)
            writer.tag(7, WireType.Bit32).fixed32(message.customFiles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_ClientInfo
 */
export const CCLCMsg_ClientInfo = new CCLCMsg_ClientInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_Move$Type extends MessageType<CCLCMsg_Move> {
    constructor() {
        super("CCLCMsg_Move", [
            { no: 1, name: "num_backup_commands", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "num_new_commands", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_Move>): CCLCMsg_Move {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_Move>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_Move): CCLCMsg_Move {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 num_backup_commands */ 1:
                    message.numBackupCommands = reader.uint32();
                    break;
                case /* optional uint32 num_new_commands */ 2:
                    message.numNewCommands = reader.uint32();
                    break;
                case /* optional bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_Move, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 num_backup_commands = 1; */
        if (message.numBackupCommands !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.numBackupCommands);
        /* optional uint32 num_new_commands = 2; */
        if (message.numNewCommands !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.numNewCommands);
        /* optional bytes data = 3; */
        if (message.data !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_Move
 */
export const CCLCMsg_Move = new CCLCMsg_Move$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_VoiceData$Type extends MessageType<CCLCMsg_VoiceData> {
    constructor() {
        super("CCLCMsg_VoiceData", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "xuid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "format", kind: "enum", opt: true, T: () => ["VoiceDataFormat_t", VoiceDataFormat_t] },
            { no: 4, name: "sequence_bytes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "section_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "uncompressed_sample_offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_VoiceData>): CCLCMsg_VoiceData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_VoiceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_VoiceData): CCLCMsg_VoiceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* optional fixed64 xuid */ 2:
                    message.xuid = reader.fixed64().toBigInt();
                    break;
                case /* optional VoiceDataFormat_t format */ 3:
                    message.format = reader.int32();
                    break;
                case /* optional int32 sequence_bytes */ 4:
                    message.sequenceBytes = reader.int32();
                    break;
                case /* optional uint32 section_number */ 5:
                    message.sectionNumber = reader.uint32();
                    break;
                case /* optional uint32 uncompressed_sample_offset */ 6:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_VoiceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* optional fixed64 xuid = 2; */
        if (message.xuid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.xuid);
        /* optional VoiceDataFormat_t format = 3; */
        if (message.format !== undefined)
            writer.tag(3, WireType.Varint).int32(message.format);
        /* optional int32 sequence_bytes = 4; */
        if (message.sequenceBytes !== undefined)
            writer.tag(4, WireType.Varint).int32(message.sequenceBytes);
        /* optional uint32 section_number = 5; */
        if (message.sectionNumber !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.sectionNumber);
        /* optional uint32 uncompressed_sample_offset = 6; */
        if (message.uncompressedSampleOffset !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.uncompressedSampleOffset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_VoiceData
 */
export const CCLCMsg_VoiceData = new CCLCMsg_VoiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_BaselineAck$Type extends MessageType<CCLCMsg_BaselineAck> {
    constructor() {
        super("CCLCMsg_BaselineAck", [
            { no: 1, name: "baseline_tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "baseline_nr", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_BaselineAck>): CCLCMsg_BaselineAck {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_BaselineAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_BaselineAck): CCLCMsg_BaselineAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 baseline_tick */ 1:
                    message.baselineTick = reader.int32();
                    break;
                case /* optional int32 baseline_nr */ 2:
                    message.baselineNr = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_BaselineAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 baseline_tick = 1; */
        if (message.baselineTick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.baselineTick);
        /* optional int32 baseline_nr = 2; */
        if (message.baselineNr !== undefined)
            writer.tag(2, WireType.Varint).int32(message.baselineNr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_BaselineAck
 */
export const CCLCMsg_BaselineAck = new CCLCMsg_BaselineAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_ListenEvents$Type extends MessageType<CCLCMsg_ListenEvents> {
    constructor() {
        super("CCLCMsg_ListenEvents", [
            { no: 1, name: "event_mask", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_ListenEvents>): CCLCMsg_ListenEvents {
        const message = { eventMask: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_ListenEvents>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_ListenEvents): CCLCMsg_ListenEvents {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 event_mask */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eventMask.push(reader.fixed32());
                    else
                        message.eventMask.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_ListenEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 event_mask = 1; */
        for (let i = 0; i < message.eventMask.length; i++)
            writer.tag(1, WireType.Bit32).fixed32(message.eventMask[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_ListenEvents
 */
export const CCLCMsg_ListenEvents = new CCLCMsg_ListenEvents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_RespondCvarValue$Type extends MessageType<CCLCMsg_RespondCvarValue> {
    constructor() {
        super("CCLCMsg_RespondCvarValue", [
            { no: 1, name: "cookie", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status_code", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_RespondCvarValue>): CCLCMsg_RespondCvarValue {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_RespondCvarValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_RespondCvarValue): CCLCMsg_RespondCvarValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cookie */ 1:
                    message.cookie = reader.int32();
                    break;
                case /* optional int32 status_code */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 4:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_RespondCvarValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cookie = 1; */
        if (message.cookie !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cookie);
        /* optional int32 status_code = 2; */
        if (message.statusCode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional string value = 4; */
        if (message.value !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_RespondCvarValue
 */
export const CCLCMsg_RespondCvarValue = new CCLCMsg_RespondCvarValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_FileCRCCheck$Type extends MessageType<CCLCMsg_FileCRCCheck> {
    constructor() {
        super("CCLCMsg_FileCRCCheck", [
            { no: 1, name: "code_path", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code_filename", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file_fraction", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "md5", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "file_hash_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "file_len", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "pack_file_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "pack_file_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_FileCRCCheck>): CCLCMsg_FileCRCCheck {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_FileCRCCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_FileCRCCheck): CCLCMsg_FileCRCCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 code_path */ 1:
                    message.codePath = reader.int32();
                    break;
                case /* optional string path */ 2:
                    message.path = reader.string();
                    break;
                case /* optional int32 code_filename */ 3:
                    message.codeFilename = reader.int32();
                    break;
                case /* optional string filename */ 4:
                    message.filename = reader.string();
                    break;
                case /* optional int32 file_fraction */ 5:
                    message.fileFraction = reader.int32();
                    break;
                case /* optional bytes md5 */ 6:
                    message.md5 = reader.bytes();
                    break;
                case /* optional uint32 crc */ 7:
                    message.crc = reader.uint32();
                    break;
                case /* optional int32 file_hash_type */ 8:
                    message.fileHashType = reader.int32();
                    break;
                case /* optional int32 file_len */ 9:
                    message.fileLen = reader.int32();
                    break;
                case /* optional int32 pack_file_id */ 10:
                    message.packFileId = reader.int32();
                    break;
                case /* optional int32 pack_file_number */ 11:
                    message.packFileNumber = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_FileCRCCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 code_path = 1; */
        if (message.codePath !== undefined)
            writer.tag(1, WireType.Varint).int32(message.codePath);
        /* optional string path = 2; */
        if (message.path !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* optional int32 code_filename = 3; */
        if (message.codeFilename !== undefined)
            writer.tag(3, WireType.Varint).int32(message.codeFilename);
        /* optional string filename = 4; */
        if (message.filename !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filename);
        /* optional int32 file_fraction = 5; */
        if (message.fileFraction !== undefined)
            writer.tag(5, WireType.Varint).int32(message.fileFraction);
        /* optional bytes md5 = 6; */
        if (message.md5 !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.md5);
        /* optional uint32 crc = 7; */
        if (message.crc !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.crc);
        /* optional int32 file_hash_type = 8; */
        if (message.fileHashType !== undefined)
            writer.tag(8, WireType.Varint).int32(message.fileHashType);
        /* optional int32 file_len = 9; */
        if (message.fileLen !== undefined)
            writer.tag(9, WireType.Varint).int32(message.fileLen);
        /* optional int32 pack_file_id = 10; */
        if (message.packFileId !== undefined)
            writer.tag(10, WireType.Varint).int32(message.packFileId);
        /* optional int32 pack_file_number = 11; */
        if (message.packFileNumber !== undefined)
            writer.tag(11, WireType.Varint).int32(message.packFileNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_FileCRCCheck
 */
export const CCLCMsg_FileCRCCheck = new CCLCMsg_FileCRCCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_LoadingProgress$Type extends MessageType<CCLCMsg_LoadingProgress> {
    constructor() {
        super("CCLCMsg_LoadingProgress", [
            { no: 1, name: "progress", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_LoadingProgress>): CCLCMsg_LoadingProgress {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_LoadingProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_LoadingProgress): CCLCMsg_LoadingProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 progress */ 1:
                    message.progress = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_LoadingProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 progress = 1; */
        if (message.progress !== undefined)
            writer.tag(1, WireType.Varint).int32(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_LoadingProgress
 */
export const CCLCMsg_LoadingProgress = new CCLCMsg_LoadingProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_SplitPlayerConnect$Type extends MessageType<CCLCMsg_SplitPlayerConnect> {
    constructor() {
        super("CCLCMsg_SplitPlayerConnect", [
            { no: 1, name: "convars", kind: "message", T: () => CMsg_CVars }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_SplitPlayerConnect>): CCLCMsg_SplitPlayerConnect {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_SplitPlayerConnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_SplitPlayerConnect): CCLCMsg_SplitPlayerConnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsg_CVars convars */ 1:
                    message.convars = CMsg_CVars.internalBinaryRead(reader, reader.uint32(), options, message.convars);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_SplitPlayerConnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsg_CVars convars = 1; */
        if (message.convars)
            CMsg_CVars.internalBinaryWrite(message.convars, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_SplitPlayerConnect
 */
export const CCLCMsg_SplitPlayerConnect = new CCLCMsg_SplitPlayerConnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_CmdKeyValues$Type extends MessageType<CCLCMsg_CmdKeyValues> {
    constructor() {
        super("CCLCMsg_CmdKeyValues", [
            { no: 1, name: "keyvalues", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_CmdKeyValues>): CCLCMsg_CmdKeyValues {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_CmdKeyValues>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_CmdKeyValues): CCLCMsg_CmdKeyValues {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes keyvalues */ 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_CmdKeyValues, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes keyvalues = 1; */
        if (message.keyvalues !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyvalues);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_CmdKeyValues
 */
export const CCLCMsg_CmdKeyValues = new CCLCMsg_CmdKeyValues$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ServerInfo$Type extends MessageType<CSVCMsg_ServerInfo> {
    constructor() {
        super("CSVCMsg_ServerInfo", [
            { no: 1, name: "protocol", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "server_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_dedicated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_official_valve_server", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_hltv", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_replay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "is_redirecting_to_proxy_relay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "c_os", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "map_crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "client_crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "string_table_crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "max_clients", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "max_classes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "player_slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "tick_interval", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "game_dir", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "map_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "map_group_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "sky_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "host_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "public_ip", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "ugc_map_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ServerInfo>): CSVCMsg_ServerInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ServerInfo): CSVCMsg_ServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 protocol */ 1:
                    message.protocol = reader.int32();
                    break;
                case /* optional int32 server_count */ 2:
                    message.serverCount = reader.int32();
                    break;
                case /* optional bool is_dedicated */ 3:
                    message.isDedicated = reader.bool();
                    break;
                case /* optional bool is_official_valve_server */ 4:
                    message.isOfficialValveServer = reader.bool();
                    break;
                case /* optional bool is_hltv */ 5:
                    message.isHltv = reader.bool();
                    break;
                case /* optional bool is_replay */ 6:
                    message.isReplay = reader.bool();
                    break;
                case /* optional bool is_redirecting_to_proxy_relay */ 21:
                    message.isRedirectingToProxyRelay = reader.bool();
                    break;
                case /* optional int32 c_os */ 7:
                    message.cOs = reader.int32();
                    break;
                case /* optional fixed32 map_crc */ 8:
                    message.mapCrc = reader.fixed32();
                    break;
                case /* optional fixed32 client_crc */ 9:
                    message.clientCrc = reader.fixed32();
                    break;
                case /* optional fixed32 string_table_crc */ 10:
                    message.stringTableCrc = reader.fixed32();
                    break;
                case /* optional int32 max_clients */ 11:
                    message.maxClients = reader.int32();
                    break;
                case /* optional int32 max_classes */ 12:
                    message.maxClasses = reader.int32();
                    break;
                case /* optional int32 player_slot */ 13:
                    message.playerSlot = reader.int32();
                    break;
                case /* optional float tick_interval */ 14:
                    message.tickInterval = reader.float();
                    break;
                case /* optional string game_dir */ 15:
                    message.gameDir = reader.string();
                    break;
                case /* optional string map_name */ 16:
                    message.mapName = reader.string();
                    break;
                case /* optional string map_group_name */ 17:
                    message.mapGroupName = reader.string();
                    break;
                case /* optional string sky_name */ 18:
                    message.skyName = reader.string();
                    break;
                case /* optional string host_name */ 19:
                    message.hostName = reader.string();
                    break;
                case /* optional uint32 public_ip */ 20:
                    message.publicIp = reader.uint32();
                    break;
                case /* optional uint64 ugc_map_id */ 22:
                    message.ugcMapId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 protocol = 1; */
        if (message.protocol !== undefined)
            writer.tag(1, WireType.Varint).int32(message.protocol);
        /* optional int32 server_count = 2; */
        if (message.serverCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.serverCount);
        /* optional bool is_dedicated = 3; */
        if (message.isDedicated !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isDedicated);
        /* optional bool is_official_valve_server = 4; */
        if (message.isOfficialValveServer !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isOfficialValveServer);
        /* optional bool is_hltv = 5; */
        if (message.isHltv !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isHltv);
        /* optional bool is_replay = 6; */
        if (message.isReplay !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isReplay);
        /* optional bool is_redirecting_to_proxy_relay = 21; */
        if (message.isRedirectingToProxyRelay !== undefined)
            writer.tag(21, WireType.Varint).bool(message.isRedirectingToProxyRelay);
        /* optional int32 c_os = 7; */
        if (message.cOs !== undefined)
            writer.tag(7, WireType.Varint).int32(message.cOs);
        /* optional fixed32 map_crc = 8; */
        if (message.mapCrc !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.mapCrc);
        /* optional fixed32 client_crc = 9; */
        if (message.clientCrc !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.clientCrc);
        /* optional fixed32 string_table_crc = 10; */
        if (message.stringTableCrc !== undefined)
            writer.tag(10, WireType.Bit32).fixed32(message.stringTableCrc);
        /* optional int32 max_clients = 11; */
        if (message.maxClients !== undefined)
            writer.tag(11, WireType.Varint).int32(message.maxClients);
        /* optional int32 max_classes = 12; */
        if (message.maxClasses !== undefined)
            writer.tag(12, WireType.Varint).int32(message.maxClasses);
        /* optional int32 player_slot = 13; */
        if (message.playerSlot !== undefined)
            writer.tag(13, WireType.Varint).int32(message.playerSlot);
        /* optional float tick_interval = 14; */
        if (message.tickInterval !== undefined)
            writer.tag(14, WireType.Bit32).float(message.tickInterval);
        /* optional string game_dir = 15; */
        if (message.gameDir !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.gameDir);
        /* optional string map_name = 16; */
        if (message.mapName !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.mapName);
        /* optional string map_group_name = 17; */
        if (message.mapGroupName !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.mapGroupName);
        /* optional string sky_name = 18; */
        if (message.skyName !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.skyName);
        /* optional string host_name = 19; */
        if (message.hostName !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.hostName);
        /* optional uint32 public_ip = 20; */
        if (message.publicIp !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.publicIp);
        /* optional uint64 ugc_map_id = 22; */
        if (message.ugcMapId !== undefined)
            writer.tag(22, WireType.Varint).uint64(message.ugcMapId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ServerInfo
 */
export const CSVCMsg_ServerInfo = new CSVCMsg_ServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ClassInfo$Type extends MessageType<CSVCMsg_ClassInfo> {
    constructor() {
        super("CSVCMsg_ClassInfo", [
            { no: 1, name: "create_on_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "classes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_ClassInfo_class_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ClassInfo>): CSVCMsg_ClassInfo {
        const message = { classes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ClassInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ClassInfo): CSVCMsg_ClassInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool create_on_client */ 1:
                    message.createOnClient = reader.bool();
                    break;
                case /* repeated CSVCMsg_ClassInfo.class_t classes */ 2:
                    message.classes.push(CSVCMsg_ClassInfo_class_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ClassInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool create_on_client = 1; */
        if (message.createOnClient !== undefined)
            writer.tag(1, WireType.Varint).bool(message.createOnClient);
        /* repeated CSVCMsg_ClassInfo.class_t classes = 2; */
        for (let i = 0; i < message.classes.length; i++)
            CSVCMsg_ClassInfo_class_t.internalBinaryWrite(message.classes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ClassInfo
 */
export const CSVCMsg_ClassInfo = new CSVCMsg_ClassInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ClassInfo_class_t$Type extends MessageType<CSVCMsg_ClassInfo_class_t> {
    constructor() {
        super("CSVCMsg_ClassInfo.class_t", [
            { no: 1, name: "class_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data_table_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ClassInfo_class_t>): CSVCMsg_ClassInfo_class_t {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ClassInfo_class_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ClassInfo_class_t): CSVCMsg_ClassInfo_class_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 class_id */ 1:
                    message.classId = reader.int32();
                    break;
                case /* optional string data_table_name */ 2:
                    message.dataTableName = reader.string();
                    break;
                case /* optional string class_name */ 3:
                    message.className = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ClassInfo_class_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 class_id = 1; */
        if (message.classId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.classId);
        /* optional string data_table_name = 2; */
        if (message.dataTableName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dataTableName);
        /* optional string class_name = 3; */
        if (message.className !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.className);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ClassInfo.class_t
 */
export const CSVCMsg_ClassInfo_class_t = new CSVCMsg_ClassInfo_class_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SendTable$Type extends MessageType<CSVCMsg_SendTable> {
    constructor() {
        super("CSVCMsg_SendTable", [
            { no: 1, name: "is_end", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "net_table_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "needs_decoder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "props", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_SendTable_sendprop_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SendTable>): CSVCMsg_SendTable {
        const message = { props: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SendTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SendTable): CSVCMsg_SendTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_end */ 1:
                    message.isEnd = reader.bool();
                    break;
                case /* optional string net_table_name */ 2:
                    message.netTableName = reader.string();
                    break;
                case /* optional bool needs_decoder */ 3:
                    message.needsDecoder = reader.bool();
                    break;
                case /* repeated CSVCMsg_SendTable.sendprop_t props */ 4:
                    message.props.push(CSVCMsg_SendTable_sendprop_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SendTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_end = 1; */
        if (message.isEnd !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isEnd);
        /* optional string net_table_name = 2; */
        if (message.netTableName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.netTableName);
        /* optional bool needs_decoder = 3; */
        if (message.needsDecoder !== undefined)
            writer.tag(3, WireType.Varint).bool(message.needsDecoder);
        /* repeated CSVCMsg_SendTable.sendprop_t props = 4; */
        for (let i = 0; i < message.props.length; i++)
            CSVCMsg_SendTable_sendprop_t.internalBinaryWrite(message.props[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SendTable
 */
export const CSVCMsg_SendTable = new CSVCMsg_SendTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SendTable_sendprop_t$Type extends MessageType<CSVCMsg_SendTable_sendprop_t> {
    constructor() {
        super("CSVCMsg_SendTable.sendprop_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "var_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "priority", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "dt_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_elements", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "low_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "high_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "num_bits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SendTable_sendprop_t>): CSVCMsg_SendTable_sendprop_t {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SendTable_sendprop_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SendTable_sendprop_t): CSVCMsg_SendTable_sendprop_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string var_name */ 2:
                    message.varName = reader.string();
                    break;
                case /* optional int32 flags */ 3:
                    message.flags = reader.int32();
                    break;
                case /* optional int32 priority */ 4:
                    message.priority = reader.int32();
                    break;
                case /* optional string dt_name */ 5:
                    message.dtName = reader.string();
                    break;
                case /* optional int32 num_elements */ 6:
                    message.numElements = reader.int32();
                    break;
                case /* optional float low_value */ 7:
                    message.lowValue = reader.float();
                    break;
                case /* optional float high_value */ 8:
                    message.highValue = reader.float();
                    break;
                case /* optional int32 num_bits */ 9:
                    message.numBits = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SendTable_sendprop_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string var_name = 2; */
        if (message.varName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.varName);
        /* optional int32 flags = 3; */
        if (message.flags !== undefined)
            writer.tag(3, WireType.Varint).int32(message.flags);
        /* optional int32 priority = 4; */
        if (message.priority !== undefined)
            writer.tag(4, WireType.Varint).int32(message.priority);
        /* optional string dt_name = 5; */
        if (message.dtName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.dtName);
        /* optional int32 num_elements = 6; */
        if (message.numElements !== undefined)
            writer.tag(6, WireType.Varint).int32(message.numElements);
        /* optional float low_value = 7; */
        if (message.lowValue !== undefined)
            writer.tag(7, WireType.Bit32).float(message.lowValue);
        /* optional float high_value = 8; */
        if (message.highValue !== undefined)
            writer.tag(8, WireType.Bit32).float(message.highValue);
        /* optional int32 num_bits = 9; */
        if (message.numBits !== undefined)
            writer.tag(9, WireType.Varint).int32(message.numBits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SendTable.sendprop_t
 */
export const CSVCMsg_SendTable_sendprop_t = new CSVCMsg_SendTable_sendprop_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Print$Type extends MessageType<CSVCMsg_Print> {
    constructor() {
        super("CSVCMsg_Print", [
            { no: 1, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Print>): CSVCMsg_Print {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Print>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Print): CSVCMsg_Print {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Print, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string text = 1; */
        if (message.text !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Print
 */
export const CSVCMsg_Print = new CSVCMsg_Print$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SetPause$Type extends MessageType<CSVCMsg_SetPause> {
    constructor() {
        super("CSVCMsg_SetPause", [
            { no: 1, name: "paused", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SetPause>): CSVCMsg_SetPause {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SetPause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SetPause): CSVCMsg_SetPause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool paused */ 1:
                    message.paused = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SetPause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool paused = 1; */
        if (message.paused !== undefined)
            writer.tag(1, WireType.Varint).bool(message.paused);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SetPause
 */
export const CSVCMsg_SetPause = new CSVCMsg_SetPause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SetView$Type extends MessageType<CSVCMsg_SetView> {
    constructor() {
        super("CSVCMsg_SetView", [
            { no: 1, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SetView>): CSVCMsg_SetView {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SetView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SetView): CSVCMsg_SetView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 entity_index */ 1:
                    message.entityIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SetView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 entity_index = 1; */
        if (message.entityIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.entityIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SetView
 */
export const CSVCMsg_SetView = new CSVCMsg_SetView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CreateStringTable$Type extends MessageType<CSVCMsg_CreateStringTable> {
    constructor() {
        super("CSVCMsg_CreateStringTable", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "num_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "user_data_fixed_size", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "user_data_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "user_data_size_bits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "string_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CreateStringTable>): CSVCMsg_CreateStringTable {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CreateStringTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CreateStringTable): CSVCMsg_CreateStringTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 max_entries */ 2:
                    message.maxEntries = reader.int32();
                    break;
                case /* optional int32 num_entries */ 3:
                    message.numEntries = reader.int32();
                    break;
                case /* optional bool user_data_fixed_size */ 4:
                    message.userDataFixedSize = reader.bool();
                    break;
                case /* optional int32 user_data_size */ 5:
                    message.userDataSize = reader.int32();
                    break;
                case /* optional int32 user_data_size_bits */ 6:
                    message.userDataSizeBits = reader.int32();
                    break;
                case /* optional int32 flags */ 7:
                    message.flags = reader.int32();
                    break;
                case /* optional bytes string_data */ 8:
                    message.stringData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CreateStringTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 max_entries = 2; */
        if (message.maxEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.maxEntries);
        /* optional int32 num_entries = 3; */
        if (message.numEntries !== undefined)
            writer.tag(3, WireType.Varint).int32(message.numEntries);
        /* optional bool user_data_fixed_size = 4; */
        if (message.userDataFixedSize !== undefined)
            writer.tag(4, WireType.Varint).bool(message.userDataFixedSize);
        /* optional int32 user_data_size = 5; */
        if (message.userDataSize !== undefined)
            writer.tag(5, WireType.Varint).int32(message.userDataSize);
        /* optional int32 user_data_size_bits = 6; */
        if (message.userDataSizeBits !== undefined)
            writer.tag(6, WireType.Varint).int32(message.userDataSizeBits);
        /* optional int32 flags = 7; */
        if (message.flags !== undefined)
            writer.tag(7, WireType.Varint).int32(message.flags);
        /* optional bytes string_data = 8; */
        if (message.stringData !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.stringData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CreateStringTable
 */
export const CSVCMsg_CreateStringTable = new CSVCMsg_CreateStringTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_UpdateStringTable$Type extends MessageType<CSVCMsg_UpdateStringTable> {
    constructor() {
        super("CSVCMsg_UpdateStringTable", [
            { no: 1, name: "table_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "num_changed_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "string_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_UpdateStringTable>): CSVCMsg_UpdateStringTable {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_UpdateStringTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_UpdateStringTable): CSVCMsg_UpdateStringTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 table_id */ 1:
                    message.tableId = reader.int32();
                    break;
                case /* optional int32 num_changed_entries */ 2:
                    message.numChangedEntries = reader.int32();
                    break;
                case /* optional bytes string_data */ 3:
                    message.stringData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_UpdateStringTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 table_id = 1; */
        if (message.tableId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tableId);
        /* optional int32 num_changed_entries = 2; */
        if (message.numChangedEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.numChangedEntries);
        /* optional bytes string_data = 3; */
        if (message.stringData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.stringData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_UpdateStringTable
 */
export const CSVCMsg_UpdateStringTable = new CSVCMsg_UpdateStringTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_VoiceInit$Type extends MessageType<CSVCMsg_VoiceInit> {
    constructor() {
        super("CSVCMsg_VoiceInit", [
            { no: 1, name: "quality", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "codec", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_VoiceInit>): CSVCMsg_VoiceInit {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_VoiceInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_VoiceInit): CSVCMsg_VoiceInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 quality */ 1:
                    message.quality = reader.int32();
                    break;
                case /* optional string codec */ 2:
                    message.codec = reader.string();
                    break;
                case /* optional int32 version */ 3:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_VoiceInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 quality = 1; */
        if (message.quality !== undefined)
            writer.tag(1, WireType.Varint).int32(message.quality);
        /* optional string codec = 2; */
        if (message.codec !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.codec);
        /* optional int32 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_VoiceInit
 */
export const CSVCMsg_VoiceInit = new CSVCMsg_VoiceInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_VoiceData$Type extends MessageType<CSVCMsg_VoiceData> {
    constructor() {
        super("CSVCMsg_VoiceData", [
            { no: 1, name: "client", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "proximity", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "xuid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "audible_mask", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "voice_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "caster", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "format", kind: "enum", opt: true, T: () => ["VoiceDataFormat_t", VoiceDataFormat_t] },
            { no: 8, name: "sequence_bytes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "section_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "uncompressed_sample_offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_VoiceData>): CSVCMsg_VoiceData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_VoiceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_VoiceData): CSVCMsg_VoiceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 client */ 1:
                    message.client = reader.int32();
                    break;
                case /* optional bool proximity */ 2:
                    message.proximity = reader.bool();
                    break;
                case /* optional fixed64 xuid */ 3:
                    message.xuid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 audible_mask */ 4:
                    message.audibleMask = reader.int32();
                    break;
                case /* optional bytes voice_data */ 5:
                    message.voiceData = reader.bytes();
                    break;
                case /* optional bool caster */ 6:
                    message.caster = reader.bool();
                    break;
                case /* optional VoiceDataFormat_t format */ 7:
                    message.format = reader.int32();
                    break;
                case /* optional int32 sequence_bytes */ 8:
                    message.sequenceBytes = reader.int32();
                    break;
                case /* optional uint32 section_number */ 9:
                    message.sectionNumber = reader.uint32();
                    break;
                case /* optional uint32 uncompressed_sample_offset */ 10:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_VoiceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 client = 1; */
        if (message.client !== undefined)
            writer.tag(1, WireType.Varint).int32(message.client);
        /* optional bool proximity = 2; */
        if (message.proximity !== undefined)
            writer.tag(2, WireType.Varint).bool(message.proximity);
        /* optional fixed64 xuid = 3; */
        if (message.xuid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.xuid);
        /* optional int32 audible_mask = 4; */
        if (message.audibleMask !== undefined)
            writer.tag(4, WireType.Varint).int32(message.audibleMask);
        /* optional bytes voice_data = 5; */
        if (message.voiceData !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.voiceData);
        /* optional bool caster = 6; */
        if (message.caster !== undefined)
            writer.tag(6, WireType.Varint).bool(message.caster);
        /* optional VoiceDataFormat_t format = 7; */
        if (message.format !== undefined)
            writer.tag(7, WireType.Varint).int32(message.format);
        /* optional int32 sequence_bytes = 8; */
        if (message.sequenceBytes !== undefined)
            writer.tag(8, WireType.Varint).int32(message.sequenceBytes);
        /* optional uint32 section_number = 9; */
        if (message.sectionNumber !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.sectionNumber);
        /* optional uint32 uncompressed_sample_offset = 10; */
        if (message.uncompressedSampleOffset !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.uncompressedSampleOffset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_VoiceData
 */
export const CSVCMsg_VoiceData = new CSVCMsg_VoiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_FixAngle$Type extends MessageType<CSVCMsg_FixAngle> {
    constructor() {
        super("CSVCMsg_FixAngle", [
            { no: 1, name: "relative", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "angle", kind: "message", T: () => CMsgQAngle }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_FixAngle>): CSVCMsg_FixAngle {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_FixAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_FixAngle): CSVCMsg_FixAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool relative */ 1:
                    message.relative = reader.bool();
                    break;
                case /* optional CMsgQAngle angle */ 2:
                    message.angle = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_FixAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool relative = 1; */
        if (message.relative !== undefined)
            writer.tag(1, WireType.Varint).bool(message.relative);
        /* optional CMsgQAngle angle = 2; */
        if (message.angle)
            CMsgQAngle.internalBinaryWrite(message.angle, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_FixAngle
 */
export const CSVCMsg_FixAngle = new CSVCMsg_FixAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CrosshairAngle$Type extends MessageType<CSVCMsg_CrosshairAngle> {
    constructor() {
        super("CSVCMsg_CrosshairAngle", [
            { no: 1, name: "angle", kind: "message", T: () => CMsgQAngle }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CrosshairAngle>): CSVCMsg_CrosshairAngle {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CrosshairAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CrosshairAngle): CSVCMsg_CrosshairAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgQAngle angle */ 1:
                    message.angle = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CrosshairAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgQAngle angle = 1; */
        if (message.angle)
            CMsgQAngle.internalBinaryWrite(message.angle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CrosshairAngle
 */
export const CSVCMsg_CrosshairAngle = new CSVCMsg_CrosshairAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Prefetch$Type extends MessageType<CSVCMsg_Prefetch> {
    constructor() {
        super("CSVCMsg_Prefetch", [
            { no: 1, name: "sound_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Prefetch>): CSVCMsg_Prefetch {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Prefetch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Prefetch): CSVCMsg_Prefetch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sound_index */ 1:
                    message.soundIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Prefetch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 sound_index = 1; */
        if (message.soundIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.soundIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Prefetch
 */
export const CSVCMsg_Prefetch = new CSVCMsg_Prefetch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_BSPDecal$Type extends MessageType<CSVCMsg_BSPDecal> {
    constructor() {
        super("CSVCMsg_BSPDecal", [
            { no: 1, name: "pos", kind: "message", T: () => CMsgVector },
            { no: 2, name: "decal_texture_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "model_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "low_priority", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_BSPDecal>): CSVCMsg_BSPDecal {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_BSPDecal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_BSPDecal): CSVCMsg_BSPDecal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgVector pos */ 1:
                    message.pos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional int32 decal_texture_index */ 2:
                    message.decalTextureIndex = reader.int32();
                    break;
                case /* optional int32 entity_index */ 3:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 model_index */ 4:
                    message.modelIndex = reader.int32();
                    break;
                case /* optional bool low_priority */ 5:
                    message.lowPriority = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_BSPDecal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgVector pos = 1; */
        if (message.pos)
            CMsgVector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 decal_texture_index = 2; */
        if (message.decalTextureIndex !== undefined)
            writer.tag(2, WireType.Varint).int32(message.decalTextureIndex);
        /* optional int32 entity_index = 3; */
        if (message.entityIndex !== undefined)
            writer.tag(3, WireType.Varint).int32(message.entityIndex);
        /* optional int32 model_index = 4; */
        if (message.modelIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.modelIndex);
        /* optional bool low_priority = 5; */
        if (message.lowPriority !== undefined)
            writer.tag(5, WireType.Varint).bool(message.lowPriority);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_BSPDecal
 */
export const CSVCMsg_BSPDecal = new CSVCMsg_BSPDecal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SplitScreen$Type extends MessageType<CSVCMsg_SplitScreen> {
    constructor() {
        super("CSVCMsg_SplitScreen", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["ESplitScreenMessageType", ESplitScreenMessageType] },
            { no: 2, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "player_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SplitScreen>): CSVCMsg_SplitScreen {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SplitScreen>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SplitScreen): CSVCMsg_SplitScreen {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESplitScreenMessageType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* optional int32 player_index */ 3:
                    message.playerIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SplitScreen, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESplitScreenMessageType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 slot = 2; */
        if (message.slot !== undefined)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* optional int32 player_index = 3; */
        if (message.playerIndex !== undefined)
            writer.tag(3, WireType.Varint).int32(message.playerIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SplitScreen
 */
export const CSVCMsg_SplitScreen = new CSVCMsg_SplitScreen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GetCvarValue$Type extends MessageType<CSVCMsg_GetCvarValue> {
    constructor() {
        super("CSVCMsg_GetCvarValue", [
            { no: 1, name: "cookie", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cvar_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GetCvarValue>): CSVCMsg_GetCvarValue {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GetCvarValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GetCvarValue): CSVCMsg_GetCvarValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cookie */ 1:
                    message.cookie = reader.int32();
                    break;
                case /* optional string cvar_name */ 2:
                    message.cvarName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GetCvarValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cookie = 1; */
        if (message.cookie !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cookie);
        /* optional string cvar_name = 2; */
        if (message.cvarName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cvarName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GetCvarValue
 */
export const CSVCMsg_GetCvarValue = new CSVCMsg_GetCvarValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Menu$Type extends MessageType<CSVCMsg_Menu> {
    constructor() {
        super("CSVCMsg_Menu", [
            { no: 1, name: "dialog_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "menu_key_values", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Menu>): CSVCMsg_Menu {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Menu>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Menu): CSVCMsg_Menu {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dialog_type */ 1:
                    message.dialogType = reader.int32();
                    break;
                case /* optional bytes menu_key_values */ 2:
                    message.menuKeyValues = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Menu, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dialog_type = 1; */
        if (message.dialogType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dialogType);
        /* optional bytes menu_key_values = 2; */
        if (message.menuKeyValues !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.menuKeyValues);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Menu
 */
export const CSVCMsg_Menu = new CSVCMsg_Menu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_UserMessage$Type extends MessageType<CSVCMsg_UserMessage> {
    constructor() {
        super("CSVCMsg_UserMessage", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "msg_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "passthrough", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_UserMessage>): CSVCMsg_UserMessage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_UserMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_UserMessage): CSVCMsg_UserMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 msg_type */ 1:
                    message.msgType = reader.int32();
                    break;
                case /* optional bytes msg_data */ 2:
                    message.msgData = reader.bytes();
                    break;
                case /* optional int32 passthrough */ 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_UserMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.msgType);
        /* optional bytes msg_data = 2; */
        if (message.msgData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.msgData);
        /* optional int32 passthrough = 3; */
        if (message.passthrough !== undefined)
            writer.tag(3, WireType.Varint).int32(message.passthrough);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_UserMessage
 */
export const CSVCMsg_UserMessage = new CSVCMsg_UserMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PaintmapData$Type extends MessageType<CSVCMsg_PaintmapData> {
    constructor() {
        super("CSVCMsg_PaintmapData", [
            { no: 1, name: "paintmap", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PaintmapData>): CSVCMsg_PaintmapData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PaintmapData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PaintmapData): CSVCMsg_PaintmapData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes paintmap */ 1:
                    message.paintmap = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PaintmapData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes paintmap = 1; */
        if (message.paintmap !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.paintmap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PaintmapData
 */
export const CSVCMsg_PaintmapData = new CSVCMsg_PaintmapData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEvent$Type extends MessageType<CSVCMsg_GameEvent> {
    constructor() {
        super("CSVCMsg_GameEvent", [
            { no: 1, name: "event_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eventid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEvent_key_t },
            { no: 4, name: "passthrough", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEvent>): CSVCMsg_GameEvent {
        const message = { keys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEvent): CSVCMsg_GameEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string event_name */ 1:
                    message.eventName = reader.string();
                    break;
                case /* optional int32 eventid */ 2:
                    message.eventid = reader.int32();
                    break;
                case /* repeated CSVCMsg_GameEvent.key_t keys */ 3:
                    message.keys.push(CSVCMsg_GameEvent_key_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 passthrough */ 4:
                    message.passthrough = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string event_name = 1; */
        if (message.eventName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.eventName);
        /* optional int32 eventid = 2; */
        if (message.eventid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eventid);
        /* repeated CSVCMsg_GameEvent.key_t keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            CSVCMsg_GameEvent_key_t.internalBinaryWrite(message.keys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 passthrough = 4; */
        if (message.passthrough !== undefined)
            writer.tag(4, WireType.Varint).int32(message.passthrough);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEvent
 */
export const CSVCMsg_GameEvent = new CSVCMsg_GameEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEvent_key_t$Type extends MessageType<CSVCMsg_GameEvent_key_t> {
    constructor() {
        super("CSVCMsg_GameEvent.key_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "val_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "val_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "val_long", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "val_short", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "val_byte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "val_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "val_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "val_wstring", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEvent_key_t>): CSVCMsg_GameEvent_key_t {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEvent_key_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEvent_key_t): CSVCMsg_GameEvent_key_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string val_string */ 2:
                    message.valString = reader.string();
                    break;
                case /* optional float val_float */ 3:
                    message.valFloat = reader.float();
                    break;
                case /* optional int32 val_long */ 4:
                    message.valLong = reader.int32();
                    break;
                case /* optional int32 val_short */ 5:
                    message.valShort = reader.int32();
                    break;
                case /* optional int32 val_byte */ 6:
                    message.valByte = reader.int32();
                    break;
                case /* optional bool val_bool */ 7:
                    message.valBool = reader.bool();
                    break;
                case /* optional uint64 val_uint64 */ 8:
                    message.valUint64 = reader.uint64().toBigInt();
                    break;
                case /* optional bytes val_wstring */ 9:
                    message.valWstring = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEvent_key_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string val_string = 2; */
        if (message.valString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.valString);
        /* optional float val_float = 3; */
        if (message.valFloat !== undefined)
            writer.tag(3, WireType.Bit32).float(message.valFloat);
        /* optional int32 val_long = 4; */
        if (message.valLong !== undefined)
            writer.tag(4, WireType.Varint).int32(message.valLong);
        /* optional int32 val_short = 5; */
        if (message.valShort !== undefined)
            writer.tag(5, WireType.Varint).int32(message.valShort);
        /* optional int32 val_byte = 6; */
        if (message.valByte !== undefined)
            writer.tag(6, WireType.Varint).int32(message.valByte);
        /* optional bool val_bool = 7; */
        if (message.valBool !== undefined)
            writer.tag(7, WireType.Varint).bool(message.valBool);
        /* optional uint64 val_uint64 = 8; */
        if (message.valUint64 !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.valUint64);
        /* optional bytes val_wstring = 9; */
        if (message.valWstring !== undefined)
            writer.tag(9, WireType.LengthDelimited).bytes(message.valWstring);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEvent.key_t
 */
export const CSVCMsg_GameEvent_key_t = new CSVCMsg_GameEvent_key_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList$Type extends MessageType<CSVCMsg_GameEventList> {
    constructor() {
        super("CSVCMsg_GameEventList", [
            { no: 1, name: "descriptors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEventList_descriptor_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList>): CSVCMsg_GameEventList {
        const message = { descriptors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList): CSVCMsg_GameEventList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CSVCMsg_GameEventList.descriptor_t descriptors */ 1:
                    message.descriptors.push(CSVCMsg_GameEventList_descriptor_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CSVCMsg_GameEventList.descriptor_t descriptors = 1; */
        for (let i = 0; i < message.descriptors.length; i++)
            CSVCMsg_GameEventList_descriptor_t.internalBinaryWrite(message.descriptors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList
 */
export const CSVCMsg_GameEventList = new CSVCMsg_GameEventList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList_key_t$Type extends MessageType<CSVCMsg_GameEventList_key_t> {
    constructor() {
        super("CSVCMsg_GameEventList.key_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList_key_t>): CSVCMsg_GameEventList_key_t {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList_key_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList_key_t): CSVCMsg_GameEventList_key_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList_key_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList.key_t
 */
export const CSVCMsg_GameEventList_key_t = new CSVCMsg_GameEventList_key_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList_descriptor_t$Type extends MessageType<CSVCMsg_GameEventList_descriptor_t> {
    constructor() {
        super("CSVCMsg_GameEventList.descriptor_t", [
            { no: 1, name: "eventid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEventList_key_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList_descriptor_t>): CSVCMsg_GameEventList_descriptor_t {
        const message = { keys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList_descriptor_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList_descriptor_t): CSVCMsg_GameEventList_descriptor_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eventid */ 1:
                    message.eventid = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated CSVCMsg_GameEventList.key_t keys */ 3:
                    message.keys.push(CSVCMsg_GameEventList_key_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList_descriptor_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eventid = 1; */
        if (message.eventid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eventid);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated CSVCMsg_GameEventList.key_t keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            CSVCMsg_GameEventList_key_t.internalBinaryWrite(message.keys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList.descriptor_t
 */
export const CSVCMsg_GameEventList_descriptor_t = new CSVCMsg_GameEventList_descriptor_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_TempEntities$Type extends MessageType<CSVCMsg_TempEntities> {
    constructor() {
        super("CSVCMsg_TempEntities", [
            { no: 1, name: "reliable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "num_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entity_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_TempEntities>): CSVCMsg_TempEntities {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_TempEntities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_TempEntities): CSVCMsg_TempEntities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool reliable */ 1:
                    message.reliable = reader.bool();
                    break;
                case /* optional int32 num_entries */ 2:
                    message.numEntries = reader.int32();
                    break;
                case /* optional bytes entity_data */ 3:
                    message.entityData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_TempEntities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool reliable = 1; */
        if (message.reliable !== undefined)
            writer.tag(1, WireType.Varint).bool(message.reliable);
        /* optional int32 num_entries = 2; */
        if (message.numEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.numEntries);
        /* optional bytes entity_data = 3; */
        if (message.entityData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.entityData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_TempEntities
 */
export const CSVCMsg_TempEntities = new CSVCMsg_TempEntities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PacketEntities$Type extends MessageType<CSVCMsg_PacketEntities> {
    constructor() {
        super("CSVCMsg_PacketEntities", [
            { no: 1, name: "max_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "updated_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_delta", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "update_baseline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "baseline", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "delta_from", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "entity_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PacketEntities>): CSVCMsg_PacketEntities {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PacketEntities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PacketEntities): CSVCMsg_PacketEntities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 max_entries */ 1:
                    message.maxEntries = reader.int32();
                    break;
                case /* optional int32 updated_entries */ 2:
                    message.updatedEntries = reader.int32();
                    break;
                case /* optional bool is_delta */ 3:
                    message.isDelta = reader.bool();
                    break;
                case /* optional bool update_baseline */ 4:
                    message.updateBaseline = reader.bool();
                    break;
                case /* optional int32 baseline */ 5:
                    message.baseline = reader.int32();
                    break;
                case /* optional int32 delta_from */ 6:
                    message.deltaFrom = reader.int32();
                    break;
                case /* optional bytes entity_data */ 7:
                    message.entityData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PacketEntities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 max_entries = 1; */
        if (message.maxEntries !== undefined)
            writer.tag(1, WireType.Varint).int32(message.maxEntries);
        /* optional int32 updated_entries = 2; */
        if (message.updatedEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.updatedEntries);
        /* optional bool is_delta = 3; */
        if (message.isDelta !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isDelta);
        /* optional bool update_baseline = 4; */
        if (message.updateBaseline !== undefined)
            writer.tag(4, WireType.Varint).bool(message.updateBaseline);
        /* optional int32 baseline = 5; */
        if (message.baseline !== undefined)
            writer.tag(5, WireType.Varint).int32(message.baseline);
        /* optional int32 delta_from = 6; */
        if (message.deltaFrom !== undefined)
            writer.tag(6, WireType.Varint).int32(message.deltaFrom);
        /* optional bytes entity_data = 7; */
        if (message.entityData !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.entityData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PacketEntities
 */
export const CSVCMsg_PacketEntities = new CSVCMsg_PacketEntities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Sounds$Type extends MessageType<CSVCMsg_Sounds> {
    constructor() {
        super("CSVCMsg_Sounds", [
            { no: 1, name: "reliable_sound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sounds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_Sounds_sounddata_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Sounds>): CSVCMsg_Sounds {
        const message = { sounds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Sounds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Sounds): CSVCMsg_Sounds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool reliable_sound */ 1:
                    message.reliableSound = reader.bool();
                    break;
                case /* repeated CSVCMsg_Sounds.sounddata_t sounds */ 2:
                    message.sounds.push(CSVCMsg_Sounds_sounddata_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Sounds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool reliable_sound = 1; */
        if (message.reliableSound !== undefined)
            writer.tag(1, WireType.Varint).bool(message.reliableSound);
        /* repeated CSVCMsg_Sounds.sounddata_t sounds = 2; */
        for (let i = 0; i < message.sounds.length; i++)
            CSVCMsg_Sounds_sounddata_t.internalBinaryWrite(message.sounds[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Sounds
 */
export const CSVCMsg_Sounds = new CSVCMsg_Sounds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Sounds_sounddata_t$Type extends MessageType<CSVCMsg_Sounds_sounddata_t> {
    constructor() {
        super("CSVCMsg_Sounds.sounddata_t", [
            { no: 1, name: "origin_x", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "origin_y", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "origin_z", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "volume", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "delay_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "sequence_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "channel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "pitch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "sound_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "sound_num_handle", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 13, name: "speaker_entity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "random_seed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "sound_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "is_sentence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_ambient", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Sounds_sounddata_t>): CSVCMsg_Sounds_sounddata_t {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Sounds_sounddata_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Sounds_sounddata_t): CSVCMsg_Sounds_sounddata_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 origin_x */ 1:
                    message.originX = reader.sint32();
                    break;
                case /* optional sint32 origin_y */ 2:
                    message.originY = reader.sint32();
                    break;
                case /* optional sint32 origin_z */ 3:
                    message.originZ = reader.sint32();
                    break;
                case /* optional uint32 volume */ 4:
                    message.volume = reader.uint32();
                    break;
                case /* optional float delay_value */ 5:
                    message.delayValue = reader.float();
                    break;
                case /* optional int32 sequence_number */ 6:
                    message.sequenceNumber = reader.int32();
                    break;
                case /* optional int32 entity_index */ 7:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 channel */ 8:
                    message.channel = reader.int32();
                    break;
                case /* optional int32 pitch */ 9:
                    message.pitch = reader.int32();
                    break;
                case /* optional int32 flags */ 10:
                    message.flags = reader.int32();
                    break;
                case /* optional uint32 sound_num */ 11:
                    message.soundNum = reader.uint32();
                    break;
                case /* optional fixed32 sound_num_handle */ 12:
                    message.soundNumHandle = reader.fixed32();
                    break;
                case /* optional int32 speaker_entity */ 13:
                    message.speakerEntity = reader.int32();
                    break;
                case /* optional int32 random_seed */ 14:
                    message.randomSeed = reader.int32();
                    break;
                case /* optional int32 sound_level */ 15:
                    message.soundLevel = reader.int32();
                    break;
                case /* optional bool is_sentence */ 16:
                    message.isSentence = reader.bool();
                    break;
                case /* optional bool is_ambient */ 17:
                    message.isAmbient = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Sounds_sounddata_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 origin_x = 1; */
        if (message.originX !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.originX);
        /* optional sint32 origin_y = 2; */
        if (message.originY !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.originY);
        /* optional sint32 origin_z = 3; */
        if (message.originZ !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.originZ);
        /* optional uint32 volume = 4; */
        if (message.volume !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.volume);
        /* optional float delay_value = 5; */
        if (message.delayValue !== undefined)
            writer.tag(5, WireType.Bit32).float(message.delayValue);
        /* optional int32 sequence_number = 6; */
        if (message.sequenceNumber !== undefined)
            writer.tag(6, WireType.Varint).int32(message.sequenceNumber);
        /* optional int32 entity_index = 7; */
        if (message.entityIndex !== undefined)
            writer.tag(7, WireType.Varint).int32(message.entityIndex);
        /* optional int32 channel = 8; */
        if (message.channel !== undefined)
            writer.tag(8, WireType.Varint).int32(message.channel);
        /* optional int32 pitch = 9; */
        if (message.pitch !== undefined)
            writer.tag(9, WireType.Varint).int32(message.pitch);
        /* optional int32 flags = 10; */
        if (message.flags !== undefined)
            writer.tag(10, WireType.Varint).int32(message.flags);
        /* optional uint32 sound_num = 11; */
        if (message.soundNum !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.soundNum);
        /* optional fixed32 sound_num_handle = 12; */
        if (message.soundNumHandle !== undefined)
            writer.tag(12, WireType.Bit32).fixed32(message.soundNumHandle);
        /* optional int32 speaker_entity = 13; */
        if (message.speakerEntity !== undefined)
            writer.tag(13, WireType.Varint).int32(message.speakerEntity);
        /* optional int32 random_seed = 14; */
        if (message.randomSeed !== undefined)
            writer.tag(14, WireType.Varint).int32(message.randomSeed);
        /* optional int32 sound_level = 15; */
        if (message.soundLevel !== undefined)
            writer.tag(15, WireType.Varint).int32(message.soundLevel);
        /* optional bool is_sentence = 16; */
        if (message.isSentence !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isSentence);
        /* optional bool is_ambient = 17; */
        if (message.isAmbient !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isAmbient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Sounds.sounddata_t
 */
export const CSVCMsg_Sounds_sounddata_t = new CSVCMsg_Sounds_sounddata_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_EntityMsg$Type extends MessageType<CSVCMsg_EntityMsg> {
    constructor() {
        super("CSVCMsg_EntityMsg", [
            { no: 1, name: "ent_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "class_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ent_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_EntityMsg>): CSVCMsg_EntityMsg {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_EntityMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_EntityMsg): CSVCMsg_EntityMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 ent_index */ 1:
                    message.entIndex = reader.int32();
                    break;
                case /* optional int32 class_id */ 2:
                    message.classId = reader.int32();
                    break;
                case /* optional bytes ent_data */ 3:
                    message.entData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_EntityMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 ent_index = 1; */
        if (message.entIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.entIndex);
        /* optional int32 class_id = 2; */
        if (message.classId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.classId);
        /* optional bytes ent_data = 3; */
        if (message.entData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.entData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_EntityMsg
 */
export const CSVCMsg_EntityMsg = new CSVCMsg_EntityMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CmdKeyValues$Type extends MessageType<CSVCMsg_CmdKeyValues> {
    constructor() {
        super("CSVCMsg_CmdKeyValues", [
            { no: 1, name: "keyvalues", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CmdKeyValues>): CSVCMsg_CmdKeyValues {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CmdKeyValues>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CmdKeyValues): CSVCMsg_CmdKeyValues {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes keyvalues */ 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CmdKeyValues, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes keyvalues = 1; */
        if (message.keyvalues !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyvalues);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CmdKeyValues
 */
export const CSVCMsg_CmdKeyValues = new CSVCMsg_CmdKeyValues$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_EncryptedData$Type extends MessageType<CSVCMsg_EncryptedData> {
    constructor() {
        super("CSVCMsg_EncryptedData", [
            { no: 1, name: "encrypted", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_EncryptedData>): CSVCMsg_EncryptedData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_EncryptedData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_EncryptedData): CSVCMsg_EncryptedData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes encrypted */ 1:
                    message.encrypted = reader.bytes();
                    break;
                case /* optional int32 key_type */ 2:
                    message.keyType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_EncryptedData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes encrypted = 1; */
        if (message.encrypted !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.encrypted);
        /* optional int32 key_type = 2; */
        if (message.keyType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.keyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_EncryptedData
 */
export const CSVCMsg_EncryptedData = new CSVCMsg_EncryptedData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_HltvReplay$Type extends MessageType<CSVCMsg_HltvReplay> {
    constructor() {
        super("CSVCMsg_HltvReplay", [
            { no: 1, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "primary_target", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "replay_stop_at", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "replay_start_at", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "replay_slowdown_begin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "replay_slowdown_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "replay_slowdown_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_HltvReplay>): CSVCMsg_HltvReplay {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_HltvReplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_HltvReplay): CSVCMsg_HltvReplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 delay */ 1:
                    message.delay = reader.int32();
                    break;
                case /* optional int32 primary_target */ 2:
                    message.primaryTarget = reader.int32();
                    break;
                case /* optional int32 replay_stop_at */ 3:
                    message.replayStopAt = reader.int32();
                    break;
                case /* optional int32 replay_start_at */ 4:
                    message.replayStartAt = reader.int32();
                    break;
                case /* optional int32 replay_slowdown_begin */ 5:
                    message.replaySlowdownBegin = reader.int32();
                    break;
                case /* optional int32 replay_slowdown_end */ 6:
                    message.replaySlowdownEnd = reader.int32();
                    break;
                case /* optional float replay_slowdown_rate */ 7:
                    message.replaySlowdownRate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_HltvReplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 delay = 1; */
        if (message.delay !== undefined)
            writer.tag(1, WireType.Varint).int32(message.delay);
        /* optional int32 primary_target = 2; */
        if (message.primaryTarget !== undefined)
            writer.tag(2, WireType.Varint).int32(message.primaryTarget);
        /* optional int32 replay_stop_at = 3; */
        if (message.replayStopAt !== undefined)
            writer.tag(3, WireType.Varint).int32(message.replayStopAt);
        /* optional int32 replay_start_at = 4; */
        if (message.replayStartAt !== undefined)
            writer.tag(4, WireType.Varint).int32(message.replayStartAt);
        /* optional int32 replay_slowdown_begin = 5; */
        if (message.replaySlowdownBegin !== undefined)
            writer.tag(5, WireType.Varint).int32(message.replaySlowdownBegin);
        /* optional int32 replay_slowdown_end = 6; */
        if (message.replaySlowdownEnd !== undefined)
            writer.tag(6, WireType.Varint).int32(message.replaySlowdownEnd);
        /* optional float replay_slowdown_rate = 7; */
        if (message.replaySlowdownRate !== undefined)
            writer.tag(7, WireType.Bit32).float(message.replaySlowdownRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_HltvReplay
 */
export const CSVCMsg_HltvReplay = new CSVCMsg_HltvReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_HltvReplay$Type extends MessageType<CCLCMsg_HltvReplay> {
    constructor() {
        super("CCLCMsg_HltvReplay", [
            { no: 1, name: "request", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slowdown_length", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "slowdown_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "primary_target_ent_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "event_time", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_HltvReplay>): CCLCMsg_HltvReplay {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_HltvReplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_HltvReplay): CCLCMsg_HltvReplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 request */ 1:
                    message.request = reader.int32();
                    break;
                case /* optional float slowdown_length */ 2:
                    message.slowdownLength = reader.float();
                    break;
                case /* optional float slowdown_rate */ 3:
                    message.slowdownRate = reader.float();
                    break;
                case /* optional int32 primary_target_ent_index */ 4:
                    message.primaryTargetEntIndex = reader.int32();
                    break;
                case /* optional float event_time */ 5:
                    message.eventTime = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_HltvReplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 request = 1; */
        if (message.request !== undefined)
            writer.tag(1, WireType.Varint).int32(message.request);
        /* optional float slowdown_length = 2; */
        if (message.slowdownLength !== undefined)
            writer.tag(2, WireType.Bit32).float(message.slowdownLength);
        /* optional float slowdown_rate = 3; */
        if (message.slowdownRate !== undefined)
            writer.tag(3, WireType.Bit32).float(message.slowdownRate);
        /* optional int32 primary_target_ent_index = 4; */
        if (message.primaryTargetEntIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.primaryTargetEntIndex);
        /* optional float event_time = 5; */
        if (message.eventTime !== undefined)
            writer.tag(5, WireType.Bit32).float(message.eventTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_HltvReplay
 */
export const CCLCMsg_HltvReplay = new CCLCMsg_HltvReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Broadcast_Command$Type extends MessageType<CSVCMsg_Broadcast_Command> {
    constructor() {
        super("CSVCMsg_Broadcast_Command", [
            { no: 1, name: "cmd", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Broadcast_Command>): CSVCMsg_Broadcast_Command {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Broadcast_Command>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Broadcast_Command): CSVCMsg_Broadcast_Command {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string cmd */ 1:
                    message.cmd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Broadcast_Command, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string cmd = 1; */
        if (message.cmd !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.cmd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Broadcast_Command
 */
export const CSVCMsg_Broadcast_Command = new CSVCMsg_Broadcast_Command$Type();
